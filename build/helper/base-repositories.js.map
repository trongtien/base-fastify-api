{
  "version": 3,
  "sources": ["../../src/helper/base-repositories.ts", "../../node_modules/src/entity.ts", "../../node_modules/src/column.ts", "../../node_modules/src/column-builder.ts", "../../node_modules/src/table.ts", "../../node_modules/src/pg-core/table.ts", "../../node_modules/src/pg-core/foreign-keys.ts", "../../node_modules/src/tracing-utils.ts", "../../node_modules/src/pg-core/unique-constraint.ts", "../../node_modules/src/pg-core/utils/array.ts", "../../node_modules/src/pg-core/columns/common.ts", "../../node_modules/src/pg-core/columns/enum.ts", "../../node_modules/src/subquery.ts", "../../node_modules/drizzle-orm/version.js", "../../node_modules/src/tracing.ts", "../../node_modules/src/view-common.ts", "../../node_modules/src/sql/sql.ts", "../../node_modules/src/sql/expressions/conditions.ts"],
  "sourcesContent": ["import { ModalQuery, QueryResultPagination } from './../type/drizzle.type';\r\nimport { and, eq, inArray, sql, SQL } from 'drizzle-orm';\r\nimport { PgSelect } from 'drizzle-orm/pg-core';\r\nimport { NodeDatabase, ObjWriteInterface } from 'type/drizzle.type';\r\n\r\nexport class BaseRepository {\r\n  protected db: NodeDatabase;\r\n\r\n  constructor(db: NodeDatabase) {\r\n    this.db = db;\r\n  }\r\n\r\n  /**\r\n   * TODO: Check data if array convert to object, if data undefined return null\r\n   * @param data\r\n   * @returns object | null\r\n   */\r\n  public transformArrayToObject<T>(data: unknown) {\r\n    const hasArray = Array.isArray(data);\r\n    if (hasArray) {\r\n      return data?.[0] ?? null;\r\n    }\r\n\r\n    if (!data) return null;\r\n\r\n    return data as T;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo insert value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param obj value insert schema\r\n   * @returns object | null\r\n   */\r\n  public async insert<T>(model: ModalQuery, obj: ObjWriteInterface): Promise<T> {\r\n    const $query = await this.db\r\n      .insert(model)\r\n      .values({ ...obj })\r\n      .returning();\r\n\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo insert many value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param arrayObj value array insert schema\r\n   * @returns boolean\r\n   */\r\n  public async insertMany(model: ModalQuery, arrayObj: ObjWriteInterface[]): Promise<boolean> {\r\n    await this.db\r\n      .insert(model)\r\n      .values([...arrayObj])\r\n      .returning();\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo update value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param obj value update schema\r\n   * @returns return object | null\r\n   */\r\n  public async update<T>(modal: ModalQuery, obj: ObjWriteInterface): Promise<T> {\r\n    const $query = await this.db\r\n      .update(modal)\r\n      .set({ ...obj })\r\n      .returning();\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo update many value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param arrayObj value array update schema\r\n   * @returns boolean\r\n   */\r\n  public async updateMany(model: ModalQuery, arrayObj: ObjWriteInterface[]): Promise<boolean> {\r\n    for (let obj of arrayObj) {\r\n      await this.update(model, obj);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo delete value with key id\r\n   * @param model type model schema and table delete\r\n   * @param id value id item delete string or array string\r\n   * @returns boolean\r\n   */\r\n  public async deleteById(model: ModalQuery, id: string | string[]): Promise<boolean> {\r\n    const hasArray = Array.isArray(id);\r\n    const $sql = hasArray ? inArray(model.id, id) : eq(model.id, id);\r\n\r\n    await this.db.delete(model).where($sql);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo delete value with object key and value\r\n   * @param model type model schema and table delete\r\n   * @param objKeyValue object key and value from query\r\n   * @returns boolean\r\n   */\r\n  public async deleteByKey(model: ModalQuery, objKeyValue: Record<string, string | number>): Promise<boolean> {\r\n    // Mapper sql to objKeyValue\r\n    let $sqlChunk: SQL[] = [];\r\n    for (const key in objKeyValue) {\r\n      const hasValue = objKeyValue[key] !== undefined && objKeyValue[key] !== null;\r\n      if (!hasValue) continue;\r\n\r\n      $sqlChunk.push(eq(model[key], objKeyValue[key]));\r\n    }\r\n\r\n    await this.db.delete(model).where(and(sql.join($sqlChunk)));\r\n    return true;\r\n  }\r\n\r\n\r\n   /**\r\n   * TODO: Base repo find fist by key\r\n   * @param model type model schema and table delete\r\n   * @param objKeyValue object key and value from query\r\n   * @returns object | null\r\n   */\r\n  public async findByKey(model: ModalQuery, objKeyValue: Record<string, string | number>) {\r\n    let $sqlChunk: SQL[] = [];\r\n    for (const key in objKeyValue) {\r\n      const hasValue = objKeyValue[key] !== undefined && objKeyValue[key] !== null;\r\n      if (!hasValue) continue;\r\n\r\n      $sqlChunk.push(eq(model[key], objKeyValue[key]));\r\n    }\r\n\r\n    const $query = await this.db\r\n      .select()\r\n      .from(model)\r\n      .where(and(sql.join($sqlChunk)))\r\n      .limit(1);\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  public async pagination<T extends PgSelect>(query: T, page: number, limit: number): Promise<QueryResultPagination> {\r\n    const subQuery = query.as('sub');\r\n    const totalRecordsQuery = this.db.select({ total: sql<number>`count(*)` }).from(subQuery);\r\n\r\n    const totalRecordsResult = await totalRecordsQuery.execute();\r\n    const totalRecords = Number(totalRecordsResult[0].total);\r\n    const totalPages = Math.ceil(totalRecords / limit);\r\n\r\n    const $offset = (page - 1) * limit;\r\n    query.limit(limit).offset($offset);\r\n\r\n    const results = (await query.execute()) as T[];\r\n\r\n    return {\r\n      data: results,\r\n      pagination: {\r\n        totalRecords: totalRecords,\r\n        totalPages: totalPages,\r\n        currentPage: page,\r\n        limit: limit,\r\n      },\r\n    };\r\n  }\r\n}\r\n", "export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = value.constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, ColumnDataType } from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly onUpdateFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.onUpdateFn = config.onUpdateFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n", "import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn } from './pg-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'common';\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T extends { $type: infer U } ? U : T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this> {\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this>;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'common' ? Column<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn : never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, TConfigMap[Key], TDialect>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n", "import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { ExtraConfigColumn } from './pg-core/index.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, ExtraConfigColumn>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown>) | undefined = undefined;\n\n\t[IsDrizzleTable] = true;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = Simplify<\n\tTInferMode extends 'insert' ? \n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n", "import type { BuildColumns, BuildExtraConfigColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport type { PgColumn, PgColumnBuilder, PgColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfig = Record<\n\tstring,\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n>;\n\nexport type TableConfig = TableConfigBase<PgColumn>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n\nexport class PgTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap,\n\textraConfig: ((self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig) | undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(columns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst builtColumnsForExtraConfig = Object.fromEntries(\n\t\tObject.entries(columns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tconst column = colBuilder.buildExtraConfigColumn(rawTable);\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn table;\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport const pgTable: PgTableFn = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[PgTable.Symbol.Name],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[PgTable.Symbol.Name],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n", "export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n", "function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n", "import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray(size?: number): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, IndexedExtraConfigType> {\n\tstatic readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport class PgArrayBuilder<\n\tT extends ColumnBuilderBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t\tsize: number | undefined;\n\t},\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: number | undefined,\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName>, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName>, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T> {\n\treadonly size: number | undefined;\n\n\tstatic readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: string, enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Gratitude to zod for the enum function types\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>> {\n\treturn pgEnumWithSchema(enumName, values, undefined);\n}\n\n/** @internal */\nexport function pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n\tschema?: string,\n): PgEnum<Writable<T>> {\n\tconst enumInstance: PgEnum<Writable<T>> = Object.assign(\n\t\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n", "import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper } from './sql/sql.ts';\n\nexport interface Subquery<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTAlias extends string = string,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<\n\tTAlias extends string = string,\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tsql: SQL;\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis._ = {\n\t\t\tbrand: 'Subquery',\n\t\t\tsql,\n\t\t\tselectedFields: selection as TSelectedFields,\n\t\t\talias: alias as TAlias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<\n\tTAlias extends string = string,\n\tTSelection extends Record<string, unknown> = Record<string, unknown>,\n> extends Subquery<TAlias, TSelection> {\n\tstatic readonly [entityKind]: string = 'WithSubquery';\n}\n", "// package.json\nvar version = \"0.31.2\";\n\n// src/version.ts\nvar compatibilityVersion = 7;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n", "import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n", "export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n", "import { entityKind, is } from '~/entity.ts';\nimport type { SelectedFields } from '~/operations.ts';\nimport { isPgEnum } from '~/pg-core/columns/enum.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(chunk.name), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tconst mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] | undefined;\n\t\t\t\tif (prepareTyping !== undefined) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isPgEnum(chunk)) {\n\t\t\t\tif (chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema) + '.' + escapeName(chunk.enumName), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload\n\tspecify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and\n\tthe type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n", "import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for greater-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('inArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('notInArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n"],
  "mappings": "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",
  "names": ["base_repositories_exports", "__export", "BaseRepository", "__toCommonJS", "entityKind", "hasOwnEntityKind", "is", "value", "type", "cls", "_a", "Column", "table", "config", "value", "entityKind", "__publicField", "_a", "ColumnBuilder", "name", "dataType", "columnType", "value", "fn", "entityKind", "__publicField", "TableName", "Schema", "Columns", "ExtraConfigColumns", "OriginalName", "BaseName", "IsAlias", "ExtraConfigBuilder", "IsDrizzleTable", "_a", "Table", "entityKind", "name", "schema", "baseName", "__publicField", "InlineForeignKeys", "_a", "PgTable", "Table", "entityKind", "__publicField", "_a", "ForeignKeyBuilder", "config", "actions", "name", "columns", "foreignColumns", "action", "table", "ForeignKey", "entityKind", "__publicField", "builder", "columnNames", "column", "foreignColumnNames", "chunks", "PgTable", "iife", "fn", "args", "uniqueKeyName", "table", "columns", "PgTable", "_a", "UniqueConstraintBuilder", "name", "UniqueConstraint", "entityKind", "__publicField", "UniqueOnConstraintBuilder", "nullsNotDistinct", "column", "parsePgArrayValue", "arrayString", "startFrom", "inQuotes", "i", "char", "parsePgNestedArray", "result", "lastCharIsComma", "value", "newStartFrom", "parsePgArray", "makePgArray", "array", "item", "_a", "PgColumnBuilder", "ColumnBuilder", "size", "PgArrayBuilder", "ref", "actions", "name", "config", "column", "table", "iife", "builder", "ForeignKeyBuilder", "foreignColumn", "ExtraConfigColumn", "entityKind", "__publicField", "PgColumn", "Column", "uniqueKeyName", "opClass", "IndexedColumn", "type", "indexConfig", "baseBuilder", "baseColumn", "PgArray", "_PgArray", "range", "value", "parsePgArray", "v", "isNestedArray", "a", "is", "makePgArray", "isPgEnumSym", "isPgEnum", "obj", "_a", "PgEnumColumnBuilder", "PgColumnBuilder", "name", "enumInstance", "table", "PgEnumColumn", "entityKind", "__publicField", "PgColumn", "config", "_a", "Subquery", "sql", "selection", "alias", "isWith", "entityKind", "__publicField", "WithSubquery", "version", "otel", "rawTracer", "tracer", "name", "fn", "version", "iife", "span", "e", "ViewBaseConfig", "_a", "FakePrimitiveParam", "entityKind", "__publicField", "isSQLWrapper", "value", "mergeQueries", "queries", "result", "query", "StringChunk", "SQL", "_SQL", "queryChunks", "noopDecoder", "config", "tracer", "span", "chunks", "_config", "escapeName", "escapeParam", "prepareTyping", "inlineParams", "paramStartIndex", "chunk", "is", "Name", "i", "p", "Table", "schemaName", "tableName", "Column", "View", "ViewBaseConfig", "viewName", "Param", "mappedValue", "typings", "Placeholder", "Subquery", "isPgEnum", "escapeString", "mappedValueAsString", "alias", "decoder", "condition", "isDriverValueEncoder", "value", "noopDecoder", "noopEncoder", "noopMapper", "_a", "Param", "encoder", "SQL", "entityKind", "__publicField", "sql", "strings", "params", "queryChunks", "StringChunk", "paramIndex", "param", "SQL", "empty", "fromList", "list", "raw", "str", "join", "chunks", "separator", "result", "i", "chunk", "identifier", "value", "Name", "placeholder", "name", "Placeholder", "encoder", "Param", "Aliased", "fieldAlias", "entityKind", "_a", "__publicField", "_a", "View", "entityKind", "ViewBaseConfig", "name", "schema", "selectedFields", "query", "SQL", "__publicField", "Column", "Table", "Subquery", "bindIfParam", "value", "column", "isDriverValueEncoder", "isSQLWrapper", "is", "Param", "Placeholder", "Column", "Table", "View", "eq", "left", "right", "sql", "and", "unfilteredConditions", "conditions", "c", "SQL", "StringChunk", "sql", "inArray", "column", "values", "sql", "v", "bindIfParam", "BaseRepository", "db", "data", "model", "obj", "$query", "arrayObj", "modal", "id", "$sql", "inArray", "eq", "objKeyValue", "$sqlChunk", "key", "and", "sql", "query", "page", "limit", "subQuery", "totalRecordsResult", "totalRecords", "totalPages", "$offset"]
}
