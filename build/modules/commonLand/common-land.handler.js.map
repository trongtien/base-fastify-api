{
  "version": 3,
  "sources": ["../../../src/modules/commonLand/common-land.handler.ts", "../../../src/helper/convert-string.ts", "../../../node_modules/src/entity.ts", "../../../node_modules/src/column.ts", "../../../node_modules/src/column-builder.ts", "../../../node_modules/src/table.ts", "../../../node_modules/src/pg-core/table.ts", "../../../node_modules/src/pg-core/foreign-keys.ts", "../../../node_modules/src/tracing-utils.ts", "../../../node_modules/src/pg-core/unique-constraint.ts", "../../../node_modules/src/pg-core/utils/array.ts", "../../../node_modules/src/pg-core/columns/common.ts", "../../../node_modules/src/pg-core/columns/enum.ts", "../../../node_modules/src/subquery.ts", "../../../node_modules/drizzle-orm/version.js", "../../../node_modules/src/tracing.ts", "../../../node_modules/src/view-common.ts", "../../../node_modules/src/sql/sql.ts", "../../../node_modules/src/alias.ts", "../../../node_modules/src/pg-core/columns/date.common.ts", "../../../node_modules/src/pg-core/columns/date.ts", "../../../node_modules/src/pg-core/columns/integer.ts", "../../../node_modules/src/pg-core/columns/json.ts", "../../../node_modules/src/pg-core/columns/jsonb.ts", "../../../node_modules/src/pg-core/columns/numeric.ts", "../../../node_modules/src/pg-core/columns/real.ts", "../../../node_modules/src/pg-core/columns/text.ts", "../../../node_modules/src/pg-core/columns/time.ts", "../../../node_modules/src/pg-core/columns/timestamp.ts", "../../../node_modules/src/pg-core/columns/uuid.ts", "../../../node_modules/src/pg-core/columns/varchar.ts", "../../../node_modules/src/query-promise.ts", "../../../node_modules/src/utils.ts", "../../../node_modules/src/errors.ts", "../../../node_modules/src/sql/expressions/conditions.ts", "../../../node_modules/src/sql/expressions/select.ts", "../../../node_modules/src/relations.ts", "../../../node_modules/src/pg-core/view-base.ts", "../../../node_modules/src/pg-core/dialect.ts", "../../../node_modules/src/selection-proxy.ts", "../../../node_modules/src/query-builders/query-builder.ts", "../../../node_modules/src/pg-core/query-builders/select.ts", "../../../node_modules/src/pg-core/query-builders/query-builder.ts", "../../../node_modules/src/pg-core/indexes.ts", "../../../node_modules/src/pg-core/view-common.ts", "../../../node_modules/src/pg-core/view.ts", "../../../node_modules/src/pg-core/schema.ts", "../../../src/models/postEstate.model.ts", "../../../src/models/images.model.ts", "../../../src/models/common-land.model.ts", "../../../src/models/postEstateDetail.model.ts", "../../../src/models/postEstateReport.model.ts", "../../../src/models/postEstateHistory.model.ts", "../../../src/helper/base-repositories.ts", "../../../src/helper/message.helper.ts", "../../../src/helper/app-exception.helper.ts", "../../../src/services/common-land.service.ts"],
  "sourcesContent": ["import { FastifyInstance } from 'fastify';\r\nimport { CommonLandService } from 'services/common-land.service';\r\nimport { Handler } from 'type/handler.type';\r\nimport { CreateCommonLandRouteInterface } from 'type/common-land.type';\r\n\r\nexport default class CommonLandHandler {\r\n  #commonLandService: CommonLandService;\r\n\r\n  constructor(private readonly app: FastifyInstance) {\r\n    this.app = app;\r\n    this.#commonLandService = new CommonLandService(this.app);\r\n  }\r\n\r\n  public create: Handler<CreateCommonLandRouteInterface> = async (request, reply) => {\r\n    const body = request.body;\r\n\r\n    const useCase = await this.#commonLandService.create({\r\n      code: body.code,\r\n      name: body.name,\r\n      provinceCode: body.province_code,\r\n      districtCode: body.district_code,\r\n      wardCode: body.ward_code\r\n    })\r\n\r\n    reply.send(useCase);\r\n  };\r\n}\r\n", "export class ConvertString {\r\n    public static convertStringToSlug(option: { text: string; slugConvert?: string }): string {\r\n      const { text, slugConvert = '-' } = option;\r\n      if (!text || text === null) {\r\n        return '';\r\n      }\r\n  \r\n      let slug;\r\n      slug = text.toLowerCase();\r\n  \r\n      slug = text.toLowerCase();\r\n      slug = slug.replace(/\u00E1|\u00E0|\u1EA3|\u1EA1|\u00E3|\u0103|\u1EAF|\u1EB1|\u1EB3|\u1EB5|\u1EB7|\u00E2|\u1EA5|\u1EA7|\u1EA9|\u1EAB|\u1EAD/gi, 'a');\r\n      slug = slug.replace(/\u00E9|\u00E8|\u1EBB|\u1EBD|\u1EB9|\u00EA|\u1EBF|\u1EC1|\u1EC3|\u1EC5|\u1EC7/gi, 'e');\r\n      slug = slug.replace(/i|\u00ED|\u00EC|\u1EC9|\u0129|\u1ECB/gi, 'i');\r\n      slug = slug.replace(/\u00F3|\u00F2|\u1ECF|\u00F5|\u1ECD|\u00F4|\u1ED1|\u1ED3|\u1ED5|\u1ED7|\u1ED9|\u01A1|\u1EDB|\u1EDD|\u1EDF|\u1EE1|\u1EE3/gi, 'o');\r\n      slug = slug.replace(/\u00FA|\u00F9|\u1EE7|\u0169|\u1EE5|\u01B0|\u1EE9|\u1EEB|\u1EED|\u1EEF|\u1EF1/gi, 'u');\r\n      slug = slug.replace(/\u00FD|\u1EF3|\u1EF7|\u1EF9|\u1EF5/gi, 'y');\r\n      slug = slug.replace(/\u0111/gi, 'd');\r\n  \r\n      slug = slug.replace(/\\`|\\~|\\!|\\@|\\#|\\||\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\+|\\=|\\,|\\.|\\/|\\?|\\>|\\<|\\'|\\\"|\\:|\\;|_/gi, '');\r\n      slug = slug.replace(/ /gi, slugConvert);\r\n      slug = slug.replace(/\\-\\-\\-\\-\\-/gi, '-');\r\n      slug = slug.replace(/\\-\\-\\-\\-/gi, '-');\r\n      slug = slug.replace(/\\-\\-\\-/gi, '-');\r\n      slug = slug.replace(/\\-\\-/gi, '-');\r\n      slug = '@' + slug + '@';\r\n      slug = slug.replace(/\\@\\-|\\-\\@|\\@/gi, '');\r\n  \r\n      return slug?.trim();\r\n    }\r\n  \r\n    public static isPathImage(url: string): boolean {\r\n      return url.match(/\\.(jpeg|jpg|gif|png)$/) != null;\r\n    }\r\n  }\r\n  ", "export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = value.constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, ColumnDataType } from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly onUpdateFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.onUpdateFn = config.onUpdateFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n", "import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn } from './pg-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'common';\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T extends { $type: infer U } ? U : T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this> {\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this>;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'common' ? Column<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn : never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, TConfigMap[Key], TDialect>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n", "import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { ExtraConfigColumn } from './pg-core/index.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, ExtraConfigColumn>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown>) | undefined = undefined;\n\n\t[IsDrizzleTable] = true;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = Simplify<\n\tTInferMode extends 'insert' ? \n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n", "import type { BuildColumns, BuildExtraConfigColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport type { PgColumn, PgColumnBuilder, PgColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfig = Record<\n\tstring,\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n>;\n\nexport type TableConfig = TableConfigBase<PgColumn>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n\nexport class PgTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap,\n\textraConfig: ((self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig) | undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(columns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst builtColumnsForExtraConfig = Object.fromEntries(\n\t\tObject.entries(columns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tconst column = colBuilder.buildExtraConfigColumn(rawTable);\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn table;\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport const pgTable: PgTableFn = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[PgTable.Symbol.Name],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[PgTable.Symbol.Name],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n", "export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n", "function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n", "import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray(size?: number): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, IndexedExtraConfigType> {\n\tstatic readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport class PgArrayBuilder<\n\tT extends ColumnBuilderBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t\tsize: number | undefined;\n\t},\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: number | undefined,\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName>, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName>, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T> {\n\treadonly size: number | undefined;\n\n\tstatic readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: string, enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Gratitude to zod for the enum function types\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>> {\n\treturn pgEnumWithSchema(enumName, values, undefined);\n}\n\n/** @internal */\nexport function pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n\tschema?: string,\n): PgEnum<Writable<T>> {\n\tconst enumInstance: PgEnum<Writable<T>> = Object.assign(\n\t\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n", "import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper } from './sql/sql.ts';\n\nexport interface Subquery<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTAlias extends string = string,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<\n\tTAlias extends string = string,\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tsql: SQL;\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis._ = {\n\t\t\tbrand: 'Subquery',\n\t\t\tsql,\n\t\t\tselectedFields: selection as TSelectedFields,\n\t\t\talias: alias as TAlias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<\n\tTAlias extends string = string,\n\tTSelection extends Record<string, unknown> = Record<string, unknown>,\n> extends Subquery<TAlias, TSelection> {\n\tstatic readonly [entityKind]: string = 'WithSubquery';\n}\n", "// package.json\nvar version = \"0.31.2\";\n\n// src/version.ts\nvar compatibilityVersion = 7;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n", "import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n", "export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n", "import { entityKind, is } from '~/entity.ts';\nimport type { SelectedFields } from '~/operations.ts';\nimport { isPgEnum } from '~/pg-core/columns/enum.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(chunk.name), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tconst mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] | undefined;\n\t\t\t\tif (prepareTyping !== undefined) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isPgEnum(chunk)) {\n\t\t\t\tif (chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema) + '.' + escapeName(chunk.enumName), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload\n\tspecify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and\n\tthe type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n", "import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport type { Relation } from './relations.ts';\nimport type { View } from './sql/sql.ts';\nimport { SQL, sql } from './sql/sql.ts';\nimport { Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class ColumnAliasProxyHandler<TColumn extends Column> implements ProxyHandler<TColumn> {\n\tstatic readonly [entityKind]: string = 'ColumnAliasProxyHandler';\n\n\tconstructor(private table: Table | View) {}\n\n\tget(columnObj: TColumn, prop: string | symbol): any {\n\t\tif (prop === 'table') {\n\t\t\treturn this.table;\n\t\t}\n\n\t\treturn columnObj[prop as keyof TColumn];\n\t}\n}\n\nexport class TableAliasProxyHandler<T extends Table | View> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'TableAliasProxyHandler';\n\n\tconstructor(private alias: string, private replaceOriginalName: boolean) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === Table.Symbol.IsAlias) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prop === Table.Symbol.Name) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...target[ViewBaseConfig as keyof typeof target],\n\t\t\t\tname: this.alias,\n\t\t\t\tisAlias: true,\n\t\t\t};\n\t\t}\n\n\t\tif (prop === Table.Symbol.Columns) {\n\t\t\tconst columns = (target as Table)[Table.Symbol.Columns];\n\t\t\tif (!columns) {\n\t\t\t\treturn columns;\n\t\t\t}\n\n\t\t\tconst proxiedColumns: { [key: string]: any } = {};\n\n\t\t\tObject.keys(columns).map((key) => {\n\t\t\t\tproxiedColumns[key] = new Proxy(\n\t\t\t\t\tcolumns[key]!,\n\t\t\t\t\tnew ColumnAliasProxyHandler(new Proxy(target, this)),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn proxiedColumns;\n\t\t}\n\n\t\tconst value = target[prop as keyof typeof target];\n\t\tif (is(value, Column)) {\n\t\t\treturn new Proxy(value as AnyColumn, new ColumnAliasProxyHandler(new Proxy(target, this)));\n\t\t}\n\n\t\treturn value;\n\t}\n}\n\nexport class RelationTableAliasProxyHandler<T extends Relation> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'RelationTableAliasProxyHandler';\n\n\tconstructor(private alias: string) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === 'sourceTable') {\n\t\t\treturn aliasedTable(target.sourceTable, this.alias);\n\t\t}\n\n\t\treturn target[prop as keyof typeof target];\n\t}\n}\n\nexport function aliasedTable<T extends Table>(table: T, tableAlias: string): T {\n\treturn new Proxy(table, new TableAliasProxyHandler(tableAlias, false));\n}\n\nexport function aliasedRelation<T extends Relation>(relation: T, tableAlias: string): T {\n\treturn new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));\n}\n\nexport function aliasedTableColumn<T extends AnyColumn>(column: T, tableAlias: string): T {\n\treturn new Proxy(\n\t\tcolumn,\n\t\tnew ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))),\n\t);\n}\n\nexport function mapColumnsInAliasedSQLToAlias(query: SQL.Aliased, alias: string): SQL.Aliased {\n\treturn new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);\n}\n\nexport function mapColumnsInSQLToAlias(query: SQL, alias: string): SQL {\n\treturn sql.join(query.queryChunks.map((c) => {\n\t\tif (is(c, Column)) {\n\t\t\treturn aliasedTableColumn(c, alias);\n\t\t}\n\t\tif (is(c, SQL)) {\n\t\t\treturn mapColumnsInSQLToAlias(c, alias);\n\t\t}\n\t\tif (is(c, SQL.Aliased)) {\n\t\t\treturn mapColumnsInAliasedSQLToAlias(c, alias);\n\t\t}\n\t\treturn c;\n\t}));\n}\n", "import type { ColumnBuilderBaseConfig, ColumnDataType } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumnBuilder } from './common.ts';\n\nexport abstract class PgDateColumnBaseBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n> extends PgColumnBuilder<T, TRuntimeConfig> {\n\tstatic readonly [entityKind]: string = 'PgDateColumnBaseBuilder';\n\n\tdefaultNow() {\n\t\treturn this.default(sql`now()`);\n\t}\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgDateBuilderInitial<TName extends string> = PgDateBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgDate';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgDate'>> extends PgDateColumnBaseBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgDateBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'date', 'PgDate');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDate<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDate<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgDate<T extends ColumnBaseConfig<'date', 'PgDate'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgDate';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n\n\toverride mapFromDriverValue(value: string): Date {\n\t\treturn new Date(value);\n\t}\n\n\toverride mapToDriverValue(value: Date): string {\n\t\treturn value.toISOString();\n\t}\n}\n\nexport type PgDateStringBuilderInitial<TName extends string> = PgDateStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgDateString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgDateString'>>\n\textends PgDateColumnBaseBuilder<T>\n{\n\tstatic readonly [entityKind]: string = 'PgDateStringBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgDateString');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDateString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDateString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgDateString<T extends ColumnBaseConfig<'string', 'PgDateString'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgDateString';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n}\n\nexport function date<TName extends string>(\n\tname: TName,\n\tconfig?: { mode: 'string' },\n): PgDateStringBuilderInitial<TName>;\nexport function date<TName extends string>(TName: TName, config?: { mode: 'date' }): PgDateBuilderInitial<TName>;\nexport function date<TName extends string>(name: TName, config?: { mode: 'date' | 'string' }) {\n\tif (config?.mode === 'date') {\n\t\treturn new PgDateBuilder(name);\n\t}\n\treturn new PgDateStringBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgIntegerBuilderInitial<TName extends string> = PgIntegerBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgInteger';\n\tdata: number;\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgInteger'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgIntegerBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgInteger');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgInteger<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgInteger<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgInteger<T extends ColumnBaseConfig<'number', 'PgInteger'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgInteger';\n\n\tgetSQLType(): string {\n\t\treturn 'integer';\n\t}\n\n\toverride mapFromDriverValue(value: number | string): number {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseInt(value);\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function integer<TName extends string>(name: TName): PgIntegerBuilderInitial<TName> {\n\treturn new PgIntegerBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonBuilderInitial<TName extends string> = PgJsonBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJson';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJson'>> extends PgColumnBuilder<\n\tT\n> {\n\tstatic readonly [entityKind]: string = 'PgJsonBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJson');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJson<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJson<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJson<T extends ColumnBaseConfig<'json', 'PgJson'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgJson';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'json';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function json<TName extends string>(name: TName): PgJsonBuilderInitial<TName> {\n\treturn new PgJsonBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonbBuilderInitial<TName extends string> = PgJsonbBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJsonb';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonbBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJsonb'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgJsonbBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJsonb');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJsonb<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJsonb<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJsonb<T extends ColumnBaseConfig<'json', 'PgJsonb'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgJsonb';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonbBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'jsonb';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function jsonb<TName extends string>(name: TName): PgJsonbBuilderInitial<TName> {\n\treturn new PgJsonbBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgNumericBuilderInitial<TName extends string> = PgNumericBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgNumeric';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgNumeric'>> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tprecision: number | undefined;\n\t\tscale: number | undefined;\n\t}\n> {\n\tstatic readonly [entityKind]: string = 'PgNumericBuilder';\n\n\tconstructor(name: string, precision?: number, scale?: number) {\n\t\tsuper(name, 'string', 'PgNumeric');\n\t\tthis.config.precision = precision;\n\t\tthis.config.scale = scale;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgNumeric<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgNumeric<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgNumeric<T extends ColumnBaseConfig<'string', 'PgNumeric'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgNumeric';\n\n\treadonly precision: number | undefined;\n\treadonly scale: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgNumericBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.precision = config.precision;\n\t\tthis.scale = config.scale;\n\t}\n\n\tgetSQLType(): string {\n\t\tif (this.precision !== undefined && this.scale !== undefined) {\n\t\t\treturn `numeric(${this.precision}, ${this.scale})`;\n\t\t} else if (this.precision === undefined) {\n\t\t\treturn 'numeric';\n\t\t} else {\n\t\t\treturn `numeric(${this.precision})`;\n\t\t}\n\t}\n}\n\nexport function numeric<TName extends string>(\n\tname: TName,\n\tconfig?:\n\t\t| { precision: number; scale?: number }\n\t\t| { precision?: number; scale: number }\n\t\t| { precision: number; scale: number },\n): PgNumericBuilderInitial<TName> {\n\treturn new PgNumericBuilder(name, config?.precision, config?.scale);\n}\n\nexport const decimal = numeric;\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgRealBuilderInitial<TName extends string> = PgRealBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgReal';\n\tdata: number;\n\tdriverParam: string | number;\n\tenumValues: undefined;\n}>;\n\nexport class PgRealBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgReal'>> extends PgColumnBuilder<\n\tT,\n\t{ length: number | undefined }\n> {\n\tstatic readonly [entityKind]: string = 'PgRealBuilder';\n\n\tconstructor(name: string, length?: number) {\n\t\tsuper(name, 'number', 'PgReal');\n\t\tthis.config.length = length;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgReal<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgReal<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgReal<T extends ColumnBaseConfig<'number', 'PgReal'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgReal';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgRealBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'real';\n\t}\n\n\toverride mapFromDriverValue = (value: string | number): number => {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseFloat(value);\n\t\t}\n\t\treturn value;\n\t};\n}\n\nexport function real<TName extends string>(name: TName): PgRealBuilderInitial<TName> {\n\treturn new PgRealBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgTextBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgTextBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgText';\n\tdata: TEnum[number];\n\tenumValues: TEnum;\n\tdriverParam: string;\n}>;\n\nexport class PgTextBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgText'>,\n> extends PgColumnBuilder<T, { enumValues: T['enumValues'] }> {\n\tstatic readonly [entityKind]: string = 'PgTextBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tconfig: PgTextConfig<T['enumValues']>,\n\t) {\n\t\tsuper(name, 'string', 'PgText');\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgText<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgText<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgText<T extends ColumnBaseConfig<'string', 'PgText'>>\n\textends PgColumn<T, { enumValues: T['enumValues'] }>\n{\n\tstatic readonly [entityKind]: string = 'PgText';\n\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn 'text';\n\t}\n}\n\nexport interface PgTextConfig<TEnum extends readonly string[] | string[] | undefined> {\n\tenum?: TEnum;\n}\n\nexport function text<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: TName,\n\tconfig: PgTextConfig<T | Writable<T>> = {},\n): PgTextBuilderInitial<TName, Writable<T>> {\n\treturn new PgTextBuilder(name, config);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\nimport type { Precision } from './timestamp.ts';\n\nexport type PgTimeBuilderInitial<TName extends string> = PgTimeBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTime';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimeBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTime'>> extends PgDateColumnBaseBuilder<\n\tT,\n\t{ withTimezone: boolean; precision: number | undefined }\n> {\n\tstatic readonly [entityKind]: string = 'PgTimeBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\treadonly withTimezone: boolean,\n\t\treadonly precision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTime');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTime<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTime<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTime<T extends ColumnBaseConfig<'string', 'PgTime'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTime';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimeBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `time${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport interface TimeConfig {\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function time<TName extends string>(name: TName, config: TimeConfig = {}): PgTimeBuilderInitial<TName> {\n\treturn new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Equal } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgTimestampBuilderInitial<TName extends string> = PgTimestampBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgTimestamp';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgTimestamp'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic readonly [entityKind]: string = 'PgTimestampBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'date', 'PgTimestamp');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestamp<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestamp<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTimestamp<T extends ColumnBaseConfig<'date', 'PgTimestamp'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTimestamp';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : ` (${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n\n\toverride mapFromDriverValue = (value: string): Date | null => {\n\t\treturn new Date(this.withTimezone ? value : value + '+0000');\n\t};\n\n\toverride mapToDriverValue = (value: Date): string => {\n\t\treturn value.toISOString();\n\t};\n}\n\nexport type PgTimestampStringBuilderInitial<TName extends string> = PgTimestampStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTimestampString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTimestampString'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic readonly [entityKind]: string = 'PgTimestampStringBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTimestampString');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestampString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestampString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgTimestampString<T extends ColumnBaseConfig<'string', 'PgTimestampString'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTimestampString';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampStringBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport type Precision = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface PgTimestampConfig<TMode extends 'date' | 'string' = 'date' | 'string'> {\n\tmode?: TMode;\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function timestamp<TName extends string, TMode extends PgTimestampConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgTimestampConfig<TMode>,\n): Equal<TMode, 'string'> extends true ? PgTimestampStringBuilderInitial<TName> : PgTimestampBuilderInitial<TName>;\nexport function timestamp(\n\tname: string,\n\tconfig: PgTimestampConfig = {},\n) {\n\tif (config.mode === 'string') {\n\t\treturn new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);\n\t}\n\treturn new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgUUIDBuilderInitial<TName extends string> = PgUUIDBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgUUID';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgUUIDBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgUUID'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgUUIDBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgUUID');\n\t}\n\n\t/**\n\t * Adds `default gen_random_uuid()` to the column definition.\n\t */\n\tdefaultRandom(): ReturnType<this['default']> {\n\t\treturn this.default(sql`gen_random_uuid()`) as ReturnType<this['default']>;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgUUID<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgUUID<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgUUID<T extends ColumnBaseConfig<'string', 'PgUUID'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgUUID';\n\n\tgetSQLType(): string {\n\t\treturn 'uuid';\n\t}\n}\n\nexport function uuid<TName extends string>(name: TName): PgUUIDBuilderInitial<TName> {\n\treturn new PgUUIDBuilder(name);\n}\n", "import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgVarcharBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgVarcharBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgVarchar';\n\tdata: TEnum[number];\n\tdriverParam: string;\n\tenumValues: TEnum;\n}>;\n\nexport class PgVarcharBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgVarchar'>> extends PgColumnBuilder<\n\tT,\n\t{ length: number | undefined; enumValues: T['enumValues'] }\n> {\n\tstatic readonly [entityKind]: string = 'PgVarcharBuilder';\n\n\tconstructor(name: string, config: PgVarcharConfig<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgVarchar');\n\t\tthis.config.length = config.length;\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgVarchar<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgVarchar<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgVarchar<T extends ColumnBaseConfig<'string', 'PgVarchar'>>\n\textends PgColumn<T, { length: number | undefined; enumValues: T['enumValues'] }>\n{\n\tstatic readonly [entityKind]: string = 'PgVarchar';\n\n\treadonly length = this.config.length;\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn this.length === undefined ? `varchar` : `varchar(${this.length})`;\n\t}\n}\n\nexport interface PgVarcharConfig<TEnum extends readonly string[] | string[] | undefined> {\n\tlength?: number;\n\tenum?: TEnum;\n}\n\nexport function varchar<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: TName,\n\tconfig: PgVarcharConfig<T | Writable<T>> = {},\n): PgVarcharBuilderInitial<TName, Writable<T>> {\n\treturn new PgVarcharBuilder(name, config);\n}\n", "import { entityKind } from '~/entity.ts';\n\nexport abstract class QueryPromise<T> implements Promise<T> {\n\tstatic readonly [entityKind]: string = 'QueryPromise';\n\n\t[Symbol.toStringTag] = 'QueryPromise';\n\n\tcatch<TResult = never>(\n\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined,\n\t): Promise<T | TResult> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\tfinally(onFinally?: (() => void) | null | undefined): Promise<T> {\n\t\treturn this.then(\n\t\t\t(value) => {\n\t\t\t\tonFinally?.();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t(reason) => {\n\t\t\t\tonFinally?.();\n\t\t\t\tthrow reason;\n\t\t\t},\n\t\t);\n\t}\n\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n\t): Promise<TResult1 | TResult2> {\n\t\treturn this.execute().then(onFulfilled, onRejected);\n\t}\n\n\tabstract execute(): Promise<T>;\n}\n", "import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> = Simplify<\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate\n>;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n", "import { entityKind } from '~/entity.ts';\n\nexport class DrizzleError extends Error {\n\tstatic readonly [entityKind]: string = 'DrizzleError';\n\n\tconstructor({ message, cause }: { message?: string; cause?: unknown }) {\n\t\tsuper(message);\n\t\tthis.name = 'DrizzleError';\n\t\tthis.cause = cause;\n\t}\n}\n\nexport class TransactionRollbackError extends DrizzleError {\n\tstatic readonly [entityKind]: string = 'TransactionRollbackError';\n\n\tconstructor() {\n\t\tsuper({ message: 'Rollback' });\n\t}\n}\n", "import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for greater-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('inArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('notInArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n", "import type { AnyColumn } from '../../column.ts';\nimport type { SQL, SQLWrapper } from '../sql.ts';\nimport { sql } from '../sql.ts';\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in ascending\n * order. By the SQL standard, ascending order is the\n * default, so it is not usually necessary to specify\n * ascending sort order.\n *\n * ## Examples\n *\n * ```ts\n * // Return cars, starting with the oldest models\n * // and going in ascending order to the newest.\n * db.select().from(cars)\n *   .orderBy(asc(cars.year));\n * ```\n *\n * @see desc to sort in descending order\n */\nexport function asc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} asc`;\n}\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in descending\n * order.\n *\n * ## Examples\n *\n * ```ts\n * // Select users, with the most recently created\n * // records coming first.\n * db.select().from(users)\n *   .orderBy(desc(users.createdAt));\n * ```\n *\n * @see asc to sort in ascending order\n */\nexport function desc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} desc`;\n}\n", "import { type AnyTable, type InferModelFromColumns, isTable, Table } from '~/table.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { PrimaryKeyBuilder } from './pg-core/primary-keys.ts';\nimport {\n\tand,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { type Placeholder, SQL, sql } from './sql/sql.ts';\nimport type { Assume, ColumnsWithTable, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport abstract class Relation<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'Relation';\n\n\tdeclare readonly $brand: 'Relation';\n\treadonly referencedTableName: TTableName;\n\tfieldName!: string;\n\n\tconstructor(\n\t\treadonly sourceTable: Table,\n\t\treadonly referencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly relationName: string | undefined,\n\t) {\n\t\tthis.referencedTableName = referencedTable[Table.Symbol.Name] as TTableName;\n\t}\n\n\tabstract withFieldName(fieldName: string): Relation<TTableName>;\n}\n\nexport class Relations<\n\tTTableName extends string = string,\n\tTConfig extends Record<string, Relation> = Record<string, Relation>,\n> {\n\tstatic readonly [entityKind]: string = 'Relations';\n\n\tdeclare readonly $brand: 'Relations';\n\n\tconstructor(\n\t\treadonly table: AnyTable<{ name: TTableName }>,\n\t\treadonly config: (helpers: TableRelationsHelpers<TTableName>) => TConfig,\n\t) {}\n}\n\nexport class One<\n\tTTableName extends string = string,\n\tTIsNullable extends boolean = boolean,\n> extends Relation<TTableName> {\n\tstatic readonly [entityKind]: string = 'One';\n\n\tdeclare protected $relationBrand: 'One';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config:\n\t\t\t| RelationConfig<\n\t\t\t\tTTableName,\n\t\t\t\tstring,\n\t\t\t\tAnyColumn<{ tableName: TTableName }>[]\n\t\t\t>\n\t\t\t| undefined,\n\t\treadonly isNullable: TIsNullable,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): One<TTableName> {\n\t\tconst relation = new One(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t\tthis.isNullable,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport class Many<TTableName extends string> extends Relation<TTableName> {\n\tstatic readonly [entityKind]: string = 'Many';\n\n\tdeclare protected $relationBrand: 'Many';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config: { relationName: string } | undefined,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): Many<TTableName> {\n\t\tconst relation = new Many(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport type TableRelationsKeysOnly<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n\tK extends keyof TSchema,\n> = TSchema[K] extends Relations<TTableName> ? K : never;\n\nexport type ExtractTableRelationsFromSchema<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TableRelationsKeysOnly<\n\t\t\t\tTSchema,\n\t\t\t\tTTableName,\n\t\t\t\tK\n\t\t\t>\n\t\t]: TSchema[K] extends Relations<TTableName, infer TConfig> ? TConfig : never;\n\t}\n>;\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport type ExtractRelationsFromTableExtraConfigSchema<\n\tTConfig extends unknown[],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TConfig as TConfig[K] extends Relations<any> ? K\n\t\t\t\t: never\n\t\t]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig\n\t\t\t: never;\n\t}\n>;\n\nexport function getOperators() {\n\treturn {\n\t\tand,\n\t\tbetween,\n\t\teq,\n\t\texists,\n\t\tgt,\n\t\tgte,\n\t\tilike,\n\t\tinArray,\n\t\tisNull,\n\t\tisNotNull,\n\t\tlike,\n\t\tlt,\n\t\tlte,\n\t\tne,\n\t\tnot,\n\t\tnotBetween,\n\t\tnotExists,\n\t\tnotLike,\n\t\tnotIlike,\n\t\tnotInArray,\n\t\tor,\n\t\tsql,\n\t};\n}\n\nexport type Operators = ReturnType<typeof getOperators>;\n\nexport function getOrderByOperators() {\n\treturn {\n\t\tsql,\n\t\tasc,\n\t\tdesc,\n\t};\n}\n\nexport type OrderByOperators = ReturnType<typeof getOrderByOperators>;\n\nexport type FindTableByDBName<\n\tTSchema extends TablesRelationalConfig,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TSchema[K]['dbName'] extends TTableName ? K\n\t\t\t\t: never\n\t\t]: TSchema[K];\n\t}\n>;\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTIsRoot extends boolean = boolean,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n> =\n\t& {\n\t\tcolumns?: {\n\t\t\t[K in keyof TTableConfig['columns']]?: boolean;\n\t\t};\n\t\twith?: {\n\t\t\t[K in keyof TTableConfig['relations']]?:\n\t\t\t\t| true\n\t\t\t\t| DBQueryConfig<\n\t\t\t\t\tTTableConfig['relations'][K] extends One ? 'one' : 'many',\n\t\t\t\t\tfalse,\n\t\t\t\t\tTSchema,\n\t\t\t\t\tFindTableByDBName<\n\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\tTTableConfig['relations'][K]['referencedTableName']\n\t\t\t\t\t>\n\t\t\t\t>;\n\t\t};\n\t\textras?:\n\t\t\t| Record<string, SQL.Aliased>\n\t\t\t| ((\n\t\t\t\tfields: Simplify<\n\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t>,\n\t\t\t\toperators: { sql: Operators['sql'] },\n\t\t\t) => Record<string, SQL.Aliased>);\n\t}\n\t& (TRelationType extends 'many' ? \n\t\t\t& {\n\t\t\t\twhere?:\n\t\t\t\t\t| SQL\n\t\t\t\t\t| undefined\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: Operators,\n\t\t\t\t\t) => SQL | undefined);\n\t\t\t\torderBy?:\n\t\t\t\t\t| ValueOrArray<AnyColumn | SQL>\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: OrderByOperators,\n\t\t\t\t\t) => ValueOrArray<AnyColumn | SQL>);\n\t\t\t\tlimit?: number | Placeholder;\n\t\t\t}\n\t\t\t& (TIsRoot extends true ? {\n\t\t\t\t\toffset?: number | Placeholder;\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t: {});\n\nexport interface TableRelationalConfig {\n\ttsName: string;\n\tdbName: string;\n\tcolumns: Record<string, Column>;\n\trelations: Record<string, Relation>;\n\tprimaryKey: AnyColumn[];\n\tschema?: string;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport interface RelationalSchemaConfig<\n\tTSchema extends TablesRelationalConfig,\n> {\n\tfullSchema: Record<string, unknown>;\n\tschema: TSchema;\n\ttableNamesMap: Record<string, string>;\n}\n\nexport type ExtractTablesWithRelations<\n\tTSchema extends Record<string, unknown>,\n> = {\n\t[\n\t\tK in keyof TSchema as TSchema[K] extends Table ? K\n\t\t\t: never\n\t]: TSchema[K] extends Table ? {\n\t\t\ttsName: K & string;\n\t\t\tdbName: TSchema[K]['_']['name'];\n\t\t\tcolumns: TSchema[K]['_']['columns'];\n\t\t\trelations: ExtractTableRelationsFromSchema<\n\t\t\t\tTSchema,\n\t\t\t\tTSchema[K]['_']['name']\n\t\t\t>;\n\t\t\tprimaryKey: AnyColumn[];\n\t\t}\n\t\t: never;\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type BuildRelationResult<\n\tTSchema extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends Record<string, Relation>,\n> = {\n\t[\n\t\tK in\n\t\t\t& NonUndefinedKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<\n\t\t\tTSchema,\n\t\t\tFindTableByDBName<TSchema, TRel['referencedTableName']>,\n\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t> extends infer TResult ? TRel extends One ? \n\t\t\t\t\t| TResult\n\t\t\t\t\t| (Equal<TRel['isNullable'], false> extends true ? null : never)\n\t\t\t: TResult[]\n\t\t: never\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n> = Equal<TFullSelection, true> extends true ? InferModelFromColumns<TTableConfig['columns']>\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (TFullSelection['columns'] extends Record<string, unknown> ? InferModelFromColumns<\n\t\t\t\t\t{\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tK in Equal<\n\t\t\t\t\t\t\t\tExclude<\n\t\t\t\t\t\t\t\t\tTFullSelection['columns'][\n\t\t\t\t\t\t\t\t\t\t& keyof TFullSelection['columns']\n\t\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tundefined\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t> extends true ? Exclude<\n\t\t\t\t\t\t\t\t\tkeyof TTableConfig['columns'],\n\t\t\t\t\t\t\t\t\tNonUndefinedKeysOnly<TFullSelection['columns']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t: \n\t\t\t\t\t\t\t\t\t& {\n\t\t\t\t\t\t\t\t\t\t[K in keyof TFullSelection['columns']]: Equal<\n\t\t\t\t\t\t\t\t\t\t\tTFullSelection['columns'][K],\n\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t\t\t\t\t\t: never;\n\t\t\t\t\t\t\t\t\t}[keyof TFullSelection['columns']]\n\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t]: TTableConfig['columns'][K];\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t: InferModelFromColumns<TTableConfig['columns']>)\n\t\t\t& (TFullSelection['extras'] extends\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t| ((...args: any[]) => Record<string, unknown>) ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: Assume<\n\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>[K],\n\t\t\t\t\t\tSQL.Aliased\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface RelationConfig<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> {\n\trelationName?: string;\n\tfields: TColumns;\n\treferences: ColumnsWithTable<TTableName, TForeignTableName, TColumns>;\n}\n\nexport function extractTablesRelationalConfig<\n\tTTables extends TablesRelationalConfig,\n>(\n\tschema: Record<string, unknown>,\n\tconfigHelpers: (table: Table) => any,\n): { tables: TTables; tableNamesMap: Record<string, string> } {\n\tif (\n\t\tObject.keys(schema).length === 1\n\t\t&& 'default' in schema\n\t\t&& !is(schema['default'], Table)\n\t) {\n\t\tschema = schema['default'] as Record<string, unknown>;\n\t}\n\n\t// table DB name -> schema table key\n\tconst tableNamesMap: Record<string, string> = {};\n\t// Table relations found before their tables - need to buffer them until we know the schema table key\n\tconst relationsBuffer: Record<\n\t\tstring,\n\t\t{ relations: Record<string, Relation>; primaryKey?: AnyColumn[] }\n\t> = {};\n\tconst tablesConfig: TablesRelationalConfig = {};\n\tfor (const [key, value] of Object.entries(schema)) {\n\t\tif (isTable(value)) {\n\t\t\tconst dbName = value[Table.Symbol.Name];\n\t\t\tconst bufferedRelations = relationsBuffer[dbName];\n\t\t\ttableNamesMap[dbName] = key;\n\t\t\ttablesConfig[key] = {\n\t\t\t\ttsName: key,\n\t\t\t\tdbName: value[Table.Symbol.Name],\n\t\t\t\tschema: value[Table.Symbol.Schema],\n\t\t\t\tcolumns: value[Table.Symbol.Columns],\n\t\t\t\trelations: bufferedRelations?.relations ?? {},\n\t\t\t\tprimaryKey: bufferedRelations?.primaryKey ?? [],\n\t\t\t};\n\n\t\t\t// Fill in primary keys\n\t\t\tfor (\n\t\t\t\tconst column of Object.values(\n\t\t\t\t\t(value as Table)[Table.Symbol.Columns],\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (column.primary) {\n\t\t\t\t\ttablesConfig[key]!.primaryKey.push(column);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.((value as Table)[Table.Symbol.ExtraConfigColumns]);\n\t\t\tif (extraConfig) {\n\t\t\t\tfor (const configEntry of Object.values(extraConfig)) {\n\t\t\t\t\tif (is(configEntry, PrimaryKeyBuilder)) {\n\t\t\t\t\t\ttablesConfig[key]!.primaryKey.push(...configEntry.columns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (is(value, Relations)) {\n\t\t\tconst dbName: string = value.table[Table.Symbol.Name];\n\t\t\tconst tableName = tableNamesMap[dbName];\n\t\t\tconst relations: Record<string, Relation> = value.config(\n\t\t\t\tconfigHelpers(value.table),\n\t\t\t);\n\t\t\tlet primaryKey: AnyColumn[] | undefined;\n\n\t\t\tfor (const [relationName, relation] of Object.entries(relations)) {\n\t\t\t\tif (tableName) {\n\t\t\t\t\tconst tableConfig = tablesConfig[tableName]!;\n\t\t\t\t\ttableConfig.relations[relationName] = relation;\n\t\t\t\t\tif (primaryKey) {\n\t\t\t\t\t\ttableConfig.primaryKey.push(...primaryKey);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(dbName in relationsBuffer)) {\n\t\t\t\t\t\trelationsBuffer[dbName] = {\n\t\t\t\t\t\t\trelations: {},\n\t\t\t\t\t\t\tprimaryKey,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\trelationsBuffer[dbName]!.relations[relationName] = relation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { tables: tablesConfig as TTables, tableNamesMap };\n}\n\nexport function relations<\n\tTTableName extends string,\n\tTRelations extends Record<string, Relation<any>>,\n>(\n\ttable: AnyTable<{ name: TTableName }>,\n\trelations: (helpers: TableRelationsHelpers<TTableName>) => TRelations,\n): Relations<TTableName, TRelations> {\n\treturn new Relations<TTableName, TRelations>(\n\t\ttable,\n\t\t(helpers: TableRelationsHelpers<TTableName>) =>\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(relations(helpers)).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue.withFieldName(key),\n\t\t\t\t]),\n\t\t\t) as TRelations,\n\t);\n}\n\nexport function createOne<TTableName extends string>(sourceTable: Table) {\n\treturn function one<\n\t\tTForeignTable extends Table,\n\t\tTColumns extends [\n\t\t\tAnyColumn<{ tableName: TTableName }>,\n\t\t\t...AnyColumn<{ tableName: TTableName }>[],\n\t\t],\n\t>(\n\t\ttable: TForeignTable,\n\t\tconfig?: RelationConfig<TTableName, TForeignTable['_']['name'], TColumns>,\n\t): One<\n\t\tTForeignTable['_']['name'],\n\t\tEqual<TColumns[number]['_']['notNull'], true>\n\t> {\n\t\treturn new One(\n\t\t\tsourceTable,\n\t\t\ttable,\n\t\t\tconfig,\n\t\t\t(config?.fields.reduce<boolean>((res, f) => res && f.notNull, true)\n\t\t\t\t?? false) as Equal<TColumns[number]['_']['notNull'], true>,\n\t\t);\n\t};\n}\n\nexport function createMany(sourceTable: Table) {\n\treturn function many<TForeignTable extends Table>(\n\t\treferencedTable: TForeignTable,\n\t\tconfig?: { relationName: string },\n\t): Many<TForeignTable['_']['name']> {\n\t\treturn new Many(sourceTable, referencedTable, config);\n\t};\n}\n\nexport interface NormalizedRelation {\n\tfields: AnyColumn[];\n\treferences: AnyColumn[];\n}\n\nexport function normalizeRelation(\n\tschema: TablesRelationalConfig,\n\ttableNamesMap: Record<string, string>,\n\trelation: Relation,\n): NormalizedRelation {\n\tif (is(relation, One) && relation.config) {\n\t\treturn {\n\t\t\tfields: relation.config.fields,\n\t\t\treferences: relation.config.references,\n\t\t};\n\t}\n\n\tconst referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];\n\tif (!referencedTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${relation.referencedTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst referencedTableConfig = schema[referencedTableTsName];\n\tif (!referencedTableConfig) {\n\t\tthrow new Error(`Table \"${referencedTableTsName}\" not found in schema`);\n\t}\n\n\tconst sourceTable = relation.sourceTable;\n\tconst sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];\n\tif (!sourceTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${sourceTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst reverseRelations: Relation[] = [];\n\tfor (\n\t\tconst referencedTableRelation of Object.values(\n\t\t\treferencedTableConfig.relations,\n\t\t)\n\t) {\n\t\tif (\n\t\t\t(relation.relationName\n\t\t\t\t&& relation !== referencedTableRelation\n\t\t\t\t&& referencedTableRelation.relationName === relation.relationName)\n\t\t\t|| (!relation.relationName\n\t\t\t\t&& referencedTableRelation.referencedTable === relation.sourceTable)\n\t\t) {\n\t\t\treverseRelations.push(referencedTableRelation);\n\t\t}\n\t}\n\n\tif (reverseRelations.length > 1) {\n\t\tthrow relation.relationName\n\t\t\t? new Error(\n\t\t\t\t`There are multiple relations with name \"${relation.relationName}\" in table \"${referencedTableTsName}\"`,\n\t\t\t)\n\t\t\t: new Error(\n\t\t\t\t`There are multiple relations between \"${referencedTableTsName}\" and \"${\n\t\t\t\t\trelation.sourceTable[Table.Symbol.Name]\n\t\t\t\t}\". Please specify relation name`,\n\t\t\t);\n\t}\n\n\tif (\n\t\treverseRelations[0]\n\t\t&& is(reverseRelations[0], One)\n\t\t&& reverseRelations[0].config\n\t) {\n\t\treturn {\n\t\t\tfields: reverseRelations[0].config.references,\n\t\t\treferences: reverseRelations[0].config.fields,\n\t\t};\n\t}\n\n\tthrow new Error(\n\t\t`There is not enough information to infer relation \"${sourceTableTsName}.${relation.fieldName}\"`,\n\t);\n}\n\nexport function createTableRelationsHelpers<TTableName extends string>(\n\tsourceTable: AnyTable<{ name: TTableName }>,\n) {\n\treturn {\n\t\tone: createOne<TTableName>(sourceTable),\n\t\tmany: createMany(sourceTable),\n\t};\n}\n\nexport type TableRelationsHelpers<TTableName extends string> = ReturnType<\n\ttypeof createTableRelationsHelpers<TTableName>\n>;\n\nexport interface BuildRelationalQueryResult<\n\tTTable extends Table = Table,\n\tTColumn extends Column = Column,\n> {\n\ttableTsKey: string;\n\tselection: {\n\t\tdbKey: string;\n\t\ttsKey: string;\n\t\tfield: TColumn | SQL | SQL.Aliased;\n\t\trelationTableTsKey: string | undefined;\n\t\tisJson: boolean;\n\t\tisExtra?: boolean;\n\t\tselection: BuildRelationalQueryResult<TTable>['selection'];\n\t}[];\n\tsql: TTable | SQL;\n}\n\nexport function mapRelationalRow(\n\ttablesConfig: TablesRelationalConfig,\n\ttableConfig: TableRelationalConfig,\n\trow: unknown[],\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (\n\t\tconst [\n\t\t\tselectionItemIndex,\n\t\t\tselectionItem,\n\t\t] of buildQueryResultSelection.entries()\n\t) {\n\t\tif (selectionItem.isJson) {\n\t\t\tconst relation = tableConfig.relations[selectionItem.tsKey]!;\n\t\t\tconst rawSubRows = row[selectionItemIndex] as\n\t\t\t\t| unknown[]\n\t\t\t\t| null\n\t\t\t\t| [null]\n\t\t\t\t| string;\n\t\t\tconst subRows = typeof rawSubRows === 'string'\n\t\t\t\t? (JSON.parse(rawSubRows) as unknown[])\n\t\t\t\t: rawSubRows;\n\t\t\tresult[selectionItem.tsKey] = is(relation, One)\n\t\t\t\t? subRows\n\t\t\t\t\t&& mapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRows,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t: (subRows as unknown[][]).map((subRow) =>\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRow,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} else {\n\t\t\tconst value = mapColumnValue(row[selectionItemIndex]);\n\t\t\tconst field = selectionItem.field!;\n\t\t\tlet decoder;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tresult[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import { entityKind } from '~/entity.ts';\nimport { type ColumnsSelection, View } from '~/sql/sql.ts';\n\nexport abstract class PgViewBase<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> extends View<TName, TExisting, TSelectedFields> {\n\tstatic readonly [entityKind]: string = 'PgViewBase';\n\n\tdeclare readonly _: View<TName, TExisting, TSelectedFields>['_'] & {\n\t\treadonly viewBrand: 'PgViewBase';\n\t};\n}\n", "import { aliasedTable, aliasedTableColumn, mapColumnsInAliasedSQLToAlias, mapColumnsInSQLToAlias } from '~/alias.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { DrizzleError } from '~/errors.ts';\nimport type { MigrationConfig, MigrationMeta } from '~/migrator.ts';\nimport {\n\tPgColumn,\n\tPgDate,\n\tPgDateString,\n\tPgJson,\n\tPgJsonb,\n\tPgNumeric,\n\tPgTime,\n\tPgTimestamp,\n\tPgTimestampString,\n\tPgUUID,\n} from '~/pg-core/columns/index.ts';\nimport type {\n\tPgDeleteConfig,\n\tPgInsertConfig,\n\tPgSelectJoinConfig,\n\tPgUpdateConfig,\n} from '~/pg-core/query-builders/index.ts';\nimport type { PgSelectConfig, SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport { PgTable } from '~/pg-core/table.ts';\nimport {\n\ttype BuildRelationalQueryResult,\n\ttype DBQueryConfig,\n\tgetOperators,\n\tgetOrderByOperators,\n\tMany,\n\tnormalizeRelation,\n\tOne,\n\ttype Relation,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { and, eq, View } from '~/sql/index.ts';\nimport {\n\ttype DriverValueEncoder,\n\ttype Name,\n\tParam,\n\ttype QueryTypingsValue,\n\ttype QueryWithTypings,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n} from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { getTableName, Table } from '~/table.ts';\nimport { orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { PgSession } from './session.ts';\nimport { PgViewBase } from './view-base.ts';\nimport type { PgMaterializedView } from './view.ts';\n\nexport class PgDialect {\n\tstatic readonly [entityKind]: string = 'PgDialect';\n\n\tasync migrate(migrations: MigrationMeta[], session: PgSession, config: string | MigrationConfig): Promise<void> {\n\t\tconst migrationsTable = typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\t\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n\t\tawait session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n\t\tawait session.execute(migrationTableCreate);\n\n\t\tconst dbMigrations = await session.all<{ id: number; hash: string; created_at: string }>(\n\t\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} order by created_at desc limit 1`,\n\t\t);\n\n\t\tconst lastDbMigration = dbMigrations[0];\n\t\tawait session.transaction(async (tx) => {\n\t\t\tfor await (const migration of migrations) {\n\t\t\t\tif (\n\t\t\t\t\t!lastDbMigration\n\t\t\t\t\t|| Number(lastDbMigration.created_at) < migration.folderMillis\n\t\t\t\t) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tawait tx.execute(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tawait tx.execute(\n\t\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tescapeName(name: string): string {\n\t\treturn `\"${name}\"`;\n\t}\n\n\tescapeParam(num: number): string {\n\t\treturn `$${num + 1}`;\n\t}\n\n\tescapeString(str: string): string {\n\t\treturn `'${str.replace(/'/g, \"''\")}'`;\n\t}\n\n\tprivate buildWithCTE(queries: Subquery[] | undefined): SQL | undefined {\n\t\tif (!queries?.length) return undefined;\n\n\t\tconst withSqlChunks = [sql`with `];\n\t\tfor (const [i, w] of queries.entries()) {\n\t\t\twithSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);\n\t\t\tif (i < queries.length - 1) {\n\t\t\t\twithSqlChunks.push(sql`, `);\n\t\t\t}\n\t\t}\n\t\twithSqlChunks.push(sql` `);\n\t\treturn sql.join(withSqlChunks);\n\t}\n\n\tbuildDeleteQuery({ table, where, returning, withList }: PgDeleteConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`${withSql}delete from ${table}${whereSql}${returningSql}`;\n\t}\n\n\tbuildUpdateSet(table: PgTable, set: UpdateSet): SQL {\n\t\tconst tableColumns = table[Table.Symbol.Columns];\n\n\t\tconst columnNames = Object.keys(tableColumns).filter((colName) =>\n\t\t\tset[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined\n\t\t);\n\n\t\tconst setSize = columnNames.length;\n\t\treturn sql.join(columnNames.flatMap((colName, i) => {\n\t\t\tconst col = tableColumns[colName]!;\n\n\t\t\tconst value = set[colName] ?? sql.param(col.onUpdateFn!(), col);\n\t\t\tconst res = sql`${sql.identifier(col.name)} = ${value}`;\n\n\t\t\tif (i < setSize - 1) {\n\t\t\t\treturn [res, sql.raw(', ')];\n\t\t\t}\n\t\t\treturn [res];\n\t\t}));\n\t}\n\n\tbuildUpdateQuery({ table, set, where, returning, withList }: PgUpdateConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst setSql = this.buildUpdateSet(table, set);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;\n\t}\n\n\t/**\n\t * Builds selection SQL with provided fields/expressions\n\t *\n\t * Examples:\n\t *\n\t * `select <selection> from`\n\t *\n\t * `insert ... returning <selection>`\n\t *\n\t * If `isSingleTable` is true, then columns won't be prefixed with table name\n\t */\n\tprivate buildSelection(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ isSingleTable = false }: { isSingleTable?: boolean } = {},\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.identifier(field.fieldAlias));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\tnew SQL(\n\t\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\t\tif (is(c, PgColumn)) {\n\t\t\t\t\t\t\t\t\t\treturn sql.identifier(c.name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(query);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(sql.identifier(field.name));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tbuildSelectQuery(\n\t\t{\n\t\t\twithList,\n\t\t\tfields,\n\t\t\tfieldsFlat,\n\t\t\twhere,\n\t\t\thaving,\n\t\t\ttable,\n\t\t\tjoins,\n\t\t\torderBy,\n\t\t\tgroupBy,\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tlockingClause,\n\t\t\tdistinct,\n\t\t\tsetOperators,\n\t\t}: PgSelectConfig,\n\t): SQL {\n\t\tconst fieldsList = fieldsFlat ?? orderSelectedFields<PgColumn>(fields);\n\t\tfor (const f of fieldsList) {\n\t\t\tif (\n\t\t\t\tis(f.field, Column)\n\t\t\t\t&& getTableName(f.field.table)\n\t\t\t\t\t!== (is(table, Subquery)\n\t\t\t\t\t\t? table._.alias\n\t\t\t\t\t\t: is(table, PgViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].name\n\t\t\t\t\t\t: is(table, SQL)\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: getTableName(table))\n\t\t\t\t&& !((table) =>\n\t\t\t\t\tjoins?.some(({ alias }) =>\n\t\t\t\t\t\talias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])\n\t\t\t\t\t))(f.field.table)\n\t\t\t) {\n\t\t\t\tconst tableName = getTableName(f.field.table);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Your \"${\n\t\t\t\t\t\tf.path.join('->')\n\t\t\t\t\t}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst isSingleTable = !joins || joins.length === 0;\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tlet distinctSql: SQL | undefined;\n\t\tif (distinct) {\n\t\t\tdistinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;\n\t\t}\n\n\t\tconst selection = this.buildSelection(fieldsList, { isSingleTable });\n\n\t\tconst tableSql = (() => {\n\t\t\tif (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {\n\t\t\t\tlet fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;\n\t\t\t\tif (table[Table.Symbol.Schema]) {\n\t\t\t\t\tfullName = sql`${sql.identifier(table[Table.Symbol.Schema]!)}.${fullName}`;\n\t\t\t\t}\n\t\t\t\treturn sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;\n\t\t\t}\n\n\t\t\treturn table;\n\t\t})();\n\n\t\tconst joinsArray: SQL[] = [];\n\n\t\tif (joins) {\n\t\t\tfor (const [index, joinMeta] of joins.entries()) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t\tconst table = joinMeta.table;\n\t\t\t\tconst lateralSql = joinMeta.lateral ? sql` lateral` : undefined;\n\n\t\t\t\tif (is(table, PgTable)) {\n\t\t\t\t\tconst tableName = table[PgTable.Symbol.Name];\n\t\t\t\t\tconst tableSchema = table[PgTable.Symbol.Schema];\n\t\t\t\t\tconst origTableName = table[PgTable.Symbol.OriginalName];\n\t\t\t\t\tconst alias = tableName === origTableName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\ttableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else if (is(table, View)) {\n\t\t\t\t\tconst viewName = table[ViewBaseConfig].name;\n\t\t\t\t\tconst viewSchema = table[ViewBaseConfig].schema;\n\t\t\t\t\tconst origViewName = table[ViewBaseConfig].originalName;\n\t\t\t\t\tconst alias = viewName === origViewName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\tviewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (index < joins.length - 1) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst joinsSql = sql.join(joinsArray);\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst havingSql = having ? sql` having ${having}` : undefined;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\torderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;\n\t\t}\n\n\t\tlet groupBySql;\n\t\tif (groupBy && groupBy.length > 0) {\n\t\t\tgroupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;\n\t\t}\n\n\t\tconst limitSql = limit ? sql` limit ${limit}` : undefined;\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\tconst lockingClauseSql = sql.empty();\n\t\tif (lockingClause) {\n\t\t\tconst clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;\n\t\t\tif (lockingClause.config.of) {\n\t\t\t\tclauseSql.append(\n\t\t\t\t\tsql` of ${\n\t\t\t\t\t\tsql.join(\n\t\t\t\t\t\t\tArray.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],\n\t\t\t\t\t\t\tsql`, `,\n\t\t\t\t\t\t)\n\t\t\t\t\t}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (lockingClause.config.noWait) {\n\t\t\t\tclauseSql.append(sql` no wait`);\n\t\t\t} else if (lockingClause.config.skipLocked) {\n\t\t\t\tclauseSql.append(sql` skip locked`);\n\t\t\t}\n\t\t\tlockingClauseSql.append(clauseSql);\n\t\t}\n\t\tconst finalQuery =\n\t\t\tsql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;\n\n\t\tif (setOperators.length > 0) {\n\t\t\treturn this.buildSetOperations(finalQuery, setOperators);\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tbuildSetOperations(leftSelect: SQL, setOperators: PgSelectConfig['setOperators']): SQL {\n\t\tconst [setOperator, ...rest] = setOperators;\n\n\t\tif (!setOperator) {\n\t\t\tthrow new Error('Cannot pass undefined values to any set operator');\n\t\t}\n\n\t\tif (rest.length === 0) {\n\t\t\treturn this.buildSetOperationQuery({ leftSelect, setOperator });\n\t\t}\n\n\t\t// Some recursive magic here\n\t\treturn this.buildSetOperations(\n\t\t\tthis.buildSetOperationQuery({ leftSelect, setOperator }),\n\t\t\trest,\n\t\t);\n\t}\n\n\tbuildSetOperationQuery({\n\t\tleftSelect,\n\t\tsetOperator: { type, isAll, rightSelect, limit, orderBy, offset },\n\t}: { leftSelect: SQL; setOperator: PgSelectConfig['setOperators'][number] }): SQL {\n\t\tconst leftChunk = sql`(${leftSelect.getSQL()}) `;\n\t\tconst rightChunk = sql`(${rightSelect.getSQL()})`;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\tconst orderByValues: (SQL<unknown> | Name)[] = [];\n\n\t\t\t// The next bit is necessary because the sql operator replaces ${table.column} with `table`.`column`\n\t\t\t// which is invalid Sql syntax, Table from one of the SELECTs cannot be used in global ORDER clause\n\t\t\tfor (const singleOrderBy of orderBy) {\n\t\t\t\tif (is(singleOrderBy, PgColumn)) {\n\t\t\t\t\torderByValues.push(sql.identifier(singleOrderBy.name));\n\t\t\t\t} else if (is(singleOrderBy, SQL)) {\n\t\t\t\t\tfor (let i = 0; i < singleOrderBy.queryChunks.length; i++) {\n\t\t\t\t\t\tconst chunk = singleOrderBy.queryChunks[i];\n\n\t\t\t\t\t\tif (is(chunk, PgColumn)) {\n\t\t\t\t\t\t\tsingleOrderBy.queryChunks[i] = sql.identifier(chunk.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t} else {\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\torderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;\n\t\t}\n\n\t\tconst limitSql = limit ? sql` limit ${limit}` : undefined;\n\n\t\tconst operatorChunk = sql.raw(`${type} ${isAll ? 'all ' : ''}`);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\treturn sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;\n\t}\n\n\tbuildInsertQuery({ table, values, onConflict, returning, withList }: PgInsertConfig): SQL {\n\t\tconst valuesSqlList: ((SQLChunk | SQL)[] | SQL)[] = [];\n\t\tconst columns: Record<string, PgColumn> = table[Table.Symbol.Columns];\n\n\t\tconst colEntries: [string, PgColumn][] = Object.entries(columns);\n\n\t\tconst insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));\n\n\t\tfor (const [valueIndex, value] of values.entries()) {\n\t\t\tconst valueList: (SQLChunk | SQL)[] = [];\n\t\t\tfor (const [fieldName, col] of colEntries) {\n\t\t\t\tconst colValue = value[fieldName];\n\t\t\t\tif (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {\n\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\tif (col.defaultFn !== undefined) {\n\t\t\t\t\t\tconst defaultFnResult = col.defaultFn();\n\t\t\t\t\t\tconst defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n\t\t\t\t\t\tvalueList.push(defaultValue);\n\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\t} else if (!col.default && col.onUpdateFn !== undefined) {\n\t\t\t\t\t\tconst onUpdateFnResult = col.onUpdateFn();\n\t\t\t\t\t\tconst newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);\n\t\t\t\t\t\tvalueList.push(newValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueList.push(sql`default`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalueList.push(colValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvaluesSqlList.push(valueList);\n\t\t\tif (valueIndex < values.length - 1) {\n\t\t\t\tvaluesSqlList.push(sql`, `);\n\t\t\t}\n\t\t}\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst valuesSql = sql.join(valuesSqlList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;\n\n\t\treturn sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;\n\t}\n\n\tbuildRefreshMaterializedViewQuery(\n\t\t{ view, concurrently, withNoData }: { view: PgMaterializedView; concurrently?: boolean; withNoData?: boolean },\n\t): SQL {\n\t\tconst concurrentlySql = concurrently ? sql` concurrently` : undefined;\n\t\tconst withNoDataSql = withNoData ? sql` with no data` : undefined;\n\n\t\treturn sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;\n\t}\n\n\tprepareTyping(encoder: DriverValueEncoder<unknown, unknown>): QueryTypingsValue {\n\t\tif (is(encoder, PgJsonb) || is(encoder, PgJson)) {\n\t\t\treturn 'json';\n\t\t} else if (is(encoder, PgNumeric)) {\n\t\t\treturn 'decimal';\n\t\t} else if (is(encoder, PgTime)) {\n\t\t\treturn 'time';\n\t\t} else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {\n\t\t\treturn 'timestamp';\n\t\t} else if (is(encoder, PgDate) || is(encoder, PgDateString)) {\n\t\t\treturn 'date';\n\t\t} else if (is(encoder, PgUUID)) {\n\t\t\treturn 'uuid';\n\t\t} else {\n\t\t\treturn 'none';\n\t\t}\n\t}\n\n\tsqlToQuery(sql: SQL, invokeSource?: 'indexes' | undefined): QueryWithTypings {\n\t\treturn sql.toQuery({\n\t\t\tescapeName: this.escapeName,\n\t\t\tescapeParam: this.escapeParam,\n\t\t\tescapeString: this.escapeString,\n\t\t\tprepareTyping: this.prepareTyping,\n\t\t\tinvokeSource,\n\t\t});\n\t}\n\n\t// buildRelationalQueryWithPK({\n\t// \tfullSchema,\n\t// \tschema,\n\t// \ttableNamesMap,\n\t// \ttable,\n\t// \ttableConfig,\n\t// \tqueryConfig: config,\n\t// \ttableAlias,\n\t// \tisRoot = false,\n\t// \tjoinOn,\n\t// }: {\n\t// \tfullSchema: Record<string, unknown>;\n\t// \tschema: TablesRelationalConfig;\n\t// \ttableNamesMap: Record<string, string>;\n\t// \ttable: PgTable;\n\t// \ttableConfig: TableRelationalConfig;\n\t// \tqueryConfig: true | DBQueryConfig<'many', true>;\n\t// \ttableAlias: string;\n\t// \tisRoot?: boolean;\n\t// \tjoinOn?: SQL;\n\t// }): BuildRelationalQueryResult<PgTable, PgColumn> {\n\t// \t// For { \"<relation>\": true }, return a table with selection of all columns\n\t// \tif (config === true) {\n\t// \t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t// \t\tconst selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((\n\t// \t\t\t[key, value],\n\t// \t\t) => ({\n\t// \t\t\tdbKey: value.name,\n\t// \t\t\ttsKey: key,\n\t// \t\t\tfield: value as PgColumn,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\n\t// \t\treturn {\n\t// \t\t\ttableTsKey: tableConfig.tsName,\n\t// \t\t\tsql: table,\n\t// \t\t\tselection,\n\t// \t\t};\n\t// \t}\n\n\t// \t// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\t// \t// let selectionForBuild = selection;\n\n\t// \tconst aliasedColumns = Object.fromEntries(\n\t// \t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t// \t);\n\n\t// \tconst aliasedRelations = Object.fromEntries(\n\t// \t\tObject.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),\n\t// \t);\n\n\t// \tconst aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);\n\n\t// \tlet where, hasUserDefinedWhere;\n\t// \tif (config.where) {\n\t// \t\tconst whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;\n\t// \t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t// \t\thasUserDefinedWhere = !!where;\n\t// \t}\n\t// \twhere = and(joinOn, where);\n\n\t// \t// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];\n\t// \tlet joins: Join[] = [];\n\t// \tlet selectedColumns: string[] = [];\n\n\t// \t// Figure out which columns to select\n\t// \tif (config.columns) {\n\t// \t\tlet isIncludeMode = false;\n\n\t// \t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t// \t\t\tif (value === undefined) {\n\t// \t\t\t\tcontinue;\n\t// \t\t\t}\n\n\t// \t\t\tif (field in tableConfig.columns) {\n\t// \t\t\t\tif (!isIncludeMode && value === true) {\n\t// \t\t\t\t\tisIncludeMode = true;\n\t// \t\t\t\t}\n\t// \t\t\t\tselectedColumns.push(field);\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tif (selectedColumns.length > 0) {\n\t// \t\t\tselectedColumns = isIncludeMode\n\t// \t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t// \t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t// \t\t}\n\t// \t} else {\n\t// \t\t// Select all columns if selection is not specified\n\t// \t\tselectedColumns = Object.keys(tableConfig.columns);\n\t// \t}\n\n\t// \t// for (const field of selectedColumns) {\n\t// \t// \tconst column = tableConfig.columns[field]! as PgColumn;\n\t// \t// \tfieldsSelection.push({ tsKey: field, value: column });\n\t// \t// }\n\n\t// \tlet initiallySelectedRelations: {\n\t// \t\ttsKey: string;\n\t// \t\tqueryConfig: true | DBQueryConfig<'many', false>;\n\t// \t\trelation: Relation;\n\t// \t}[] = [];\n\n\t// \t// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\n\t// \t// Figure out which relations to select\n\t// \tif (config.with) {\n\t// \t\tinitiallySelectedRelations = Object.entries(config.with)\n\t// \t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t// \t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t// \t}\n\n\t// \tconst manyRelations = initiallySelectedRelations.filter((r) =>\n\t// \t\tis(r.relation, Many)\n\t// \t\t&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0\n\t// \t);\n\t// \t// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level\n\t// \tconst isInnermostQuery = manyRelations.length < 2;\n\n\t// \tconst selectedExtras: {\n\t// \t\ttsKey: string;\n\t// \t\tvalue: SQL.Aliased;\n\t// \t}[] = [];\n\n\t// \t// Figure out which extras to select\n\t// \tif (isInnermostQuery && config.extras) {\n\t// \t\tconst extras = typeof config.extras === 'function'\n\t// \t\t\t? config.extras(aliasedFields, { sql })\n\t// \t\t\t: config.extras;\n\t// \t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t// \t\t\tselectedExtras.push({\n\t// \t\t\t\ttsKey,\n\t// \t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t// \t\t\t});\n\t// \t\t}\n\t// \t}\n\n\t// \t// Transform `fieldsSelection` into `selection`\n\t// \t// `fieldsSelection` shouldn't be used after this point\n\t// \t// for (const { tsKey, value, isExtra } of fieldsSelection) {\n\t// \t// \tselection.push({\n\t// \t// \t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t// \t// \t\ttsKey,\n\t// \t// \t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t// \t// \t\trelationTableTsKey: undefined,\n\t// \t// \t\tisJson: false,\n\t// \t// \t\tisExtra,\n\t// \t// \t\tselection: [],\n\t// \t// \t});\n\t// \t// }\n\n\t// \tlet orderByOrig = typeof config.orderBy === 'function'\n\t// \t\t? config.orderBy(aliasedFields, orderByOperators)\n\t// \t\t: config.orderBy ?? [];\n\t// \tif (!Array.isArray(orderByOrig)) {\n\t// \t\torderByOrig = [orderByOrig];\n\t// \t}\n\t// \tconst orderBy = orderByOrig.map((orderByValue) => {\n\t// \t\tif (is(orderByValue, Column)) {\n\t// \t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as PgColumn;\n\t// \t\t}\n\t// \t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t// \t});\n\n\t// \tconst limit = isInnermostQuery ? config.limit : undefined;\n\t// \tconst offset = isInnermostQuery ? config.offset : undefined;\n\n\t// \t// For non-root queries without additional config except columns, return a table with selection\n\t// \tif (\n\t// \t\t!isRoot\n\t// \t\t&& initiallySelectedRelations.length === 0\n\t// \t\t&& selectedExtras.length === 0\n\t// \t\t&& !where\n\t// \t\t&& orderBy.length === 0\n\t// \t\t&& limit === undefined\n\t// \t\t&& offset === undefined\n\t// \t) {\n\t// \t\treturn {\n\t// \t\t\ttableTsKey: tableConfig.tsName,\n\t// \t\t\tsql: table,\n\t// \t\t\tselection: selectedColumns.map((key) => ({\n\t// \t\t\t\tdbKey: tableConfig.columns[key]!.name,\n\t// \t\t\t\ttsKey: key,\n\t// \t\t\t\tfield: tableConfig.columns[key] as PgColumn,\n\t// \t\t\t\trelationTableTsKey: undefined,\n\t// \t\t\t\tisJson: false,\n\t// \t\t\t\tselection: [],\n\t// \t\t\t})),\n\t// \t\t};\n\t// \t}\n\n\t// \tconst selectedRelationsWithoutPK:\n\n\t// \t// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level\n\t// \tfor (\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\trelation,\n\t// \t\t} of initiallySelectedRelations\n\t// \t) {\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTable = schema[relationTableTsName]!;\n\n\t// \t\tif (relationTable.primaryKey.length > 0) {\n\t// \t\t\tcontinue;\n\t// \t\t}\n\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\t// \t\tconst builtRelation = this.buildRelationalQueryWithoutPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t\tnestedQueryRelation: relation,\n\t// \t\t});\n\t// \t\tconst field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);\n\t// \t\tjoins.push({\n\t// \t\t\ton: sql`true`,\n\t// \t\t\ttable: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: true,\n\t// \t\t});\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelation.selection,\n\t// \t\t});\n\t// \t}\n\n\t// \tconst oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>\n\t// \t\tis(r.relation, One)\n\t// \t);\n\n\t// \t// Process all One relations with PKs, because they can all be joined on the same level\n\t// \tfor (\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\trelation,\n\t// \t\t} of oneRelations\n\t// \t) {\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst relationTable = schema[relationTableTsName]!;\n\n\t// \t\tif (relationTable.primaryKey.length === 0) {\n\t// \t\t\tcontinue;\n\t// \t\t}\n\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\t// \t\tconst builtRelation = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t});\n\t// \t\tconst field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${\n\t// \t\t\tsql.join(\n\t// \t\t\t\tbuiltRelation.selection.map(({ field }) =>\n\t// \t\t\t\t\tis(field, SQL.Aliased)\n\t// \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n\t// \t\t\t\t\t\t: is(field, Column)\n\t// \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n\t// \t\t\t\t\t\t: field\n\t// \t\t\t\t),\n\t// \t\t\t\tsql`, `,\n\t// \t\t\t)\n\t// \t\t}) end`.as(selectedRelationTsKey);\n\t// \t\tconst isLateralJoin = is(builtRelation.sql, SQL);\n\t// \t\tjoins.push({\n\t// \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n\t// \t\t\ttable: is(builtRelation.sql, SQL)\n\t// \t\t\t\t? new Subquery(builtRelation.sql, {}, relationTableAlias)\n\t// \t\t\t\t: aliasedTable(builtRelation.sql, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: is(builtRelation.sql, SQL),\n\t// \t\t});\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelation.selection,\n\t// \t\t});\n\t// \t}\n\n\t// \tlet distinct: PgSelectConfig['distinct'];\n\t// \tlet tableFrom: PgTable | Subquery = table;\n\n\t// \t// Process first Many relation - each one requires a nested subquery\n\t// \tconst manyRelation = manyRelations[0];\n\t// \tif (manyRelation) {\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationQueryConfig,\n\t// \t\t\trelation,\n\t// \t\t} = manyRelation;\n\n\t// \t\tdistinct = {\n\t// \t\t\ton: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),\n\t// \t\t};\n\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\n\t// \t\tconst builtRelationJoin = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationQueryConfig,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t});\n\n\t// \t\tconst builtRelationSelectionField = sql`case when ${\n\t// \t\t\tsql.identifier(relationTableAlias)\n\t// \t\t} is null then '[]' else json_agg(json_build_array(${\n\t// \t\t\tsql.join(\n\t// \t\t\t\tbuiltRelationJoin.selection.map(({ field }) =>\n\t// \t\t\t\t\tis(field, SQL.Aliased)\n\t// \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n\t// \t\t\t\t\t\t: is(field, Column)\n\t// \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n\t// \t\t\t\t\t\t: field\n\t// \t\t\t\t),\n\t// \t\t\t\tsql`, `,\n\t// \t\t\t)\n\t// \t\t})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);\n\t// \t\tconst isLateralJoin = is(builtRelationJoin.sql, SQL);\n\t// \t\tjoins.push({\n\t// \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n\t// \t\t\ttable: isLateralJoin\n\t// \t\t\t\t? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)\n\t// \t\t\t\t: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: isLateralJoin,\n\t// \t\t});\n\n\t// \t\t// Build the \"from\" subquery with the remaining Many relations\n\t// \t\tconst builtTableFrom = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable,\n\t// \t\t\ttableConfig,\n\t// \t\t\tqueryConfig: {\n\t// \t\t\t\t...config,\n\t// \t\t\t\twhere: undefined,\n\t// \t\t\t\torderBy: undefined,\n\t// \t\t\t\tlimit: undefined,\n\t// \t\t\t\toffset: undefined,\n\t// \t\t\t\twith: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(\n\t// \t\t\t\t\t(result, { tsKey, queryConfig: configValue }) => {\n\t// \t\t\t\t\t\tresult[tsKey] = configValue;\n\t// \t\t\t\t\t\treturn result;\n\t// \t\t\t\t\t},\n\t// \t\t\t\t\t{},\n\t// \t\t\t\t),\n\t// \t\t\t},\n\t// \t\t\ttableAlias,\n\t// \t\t});\n\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield: builtRelationSelectionField,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelationJoin.selection,\n\t// \t\t});\n\n\t// \t\t// selection = builtTableFrom.selection.map((item) =>\n\t// \t\t// \tis(item.field, SQL.Aliased)\n\t// \t\t// \t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n\t// \t\t// \t\t: item\n\t// \t\t// );\n\t// \t\t// selectionForBuild = [{\n\t// \t\t// \tdbKey: '*',\n\t// \t\t// \ttsKey: '*',\n\t// \t\t// \tfield: sql`${sql.identifier(tableAlias)}.*`,\n\t// \t\t// \tselection: [],\n\t// \t\t// \tisJson: false,\n\t// \t\t// \trelationTableTsKey: undefined,\n\t// \t\t// }];\n\t// \t\t// const newSelectionItem: (typeof selection)[number] = {\n\t// \t\t// \tdbKey: selectedRelationTsKey,\n\t// \t\t// \ttsKey: selectedRelationTsKey,\n\t// \t\t// \tfield,\n\t// \t\t// \trelationTableTsKey: relationTableTsName,\n\t// \t\t// \tisJson: true,\n\t// \t\t// \tselection: builtRelationJoin.selection,\n\t// \t\t// };\n\t// \t\t// selection.push(newSelectionItem);\n\t// \t\t// selectionForBuild.push(newSelectionItem);\n\n\t// \t\ttableFrom = is(builtTableFrom.sql, PgTable)\n\t// \t\t\t? builtTableFrom.sql\n\t// \t\t\t: new Subquery(builtTableFrom.sql, {}, tableAlias);\n\t// \t}\n\n\t// \tif (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {\n\t// \t\tthrow new DrizzleError(`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")`);\n\t// \t}\n\n\t// \tlet selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];\n\n\t// \tfunction prepareSelectedColumns() {\n\t// \t\treturn selectedColumns.map((key) => ({\n\t// \t\t\tdbKey: tableConfig.columns[key]!.name,\n\t// \t\t\ttsKey: key,\n\t// \t\t\tfield: tableConfig.columns[key] as PgColumn,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\t// \t}\n\n\t// \tfunction prepareSelectedExtras() {\n\t// \t\treturn selectedExtras.map((item) => ({\n\t// \t\t\tdbKey: item.value.fieldAlias,\n\t// \t\t\ttsKey: item.tsKey,\n\t// \t\t\tfield: item.value,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\t// \t}\n\n\t// \tif (isRoot) {\n\t// \t\tselection = [\n\t// \t\t\t...prepareSelectedColumns(),\n\t// \t\t\t...prepareSelectedExtras(),\n\t// \t\t];\n\t// \t}\n\n\t// \tif (hasUserDefinedWhere || orderBy.length > 0) {\n\t// \t\ttableFrom = new Subquery(\n\t// \t\t\tthis.buildSelectQuery({\n\t// \t\t\t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n\t// \t\t\t\tfields: {},\n\t// \t\t\t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n\t// \t\t\t\t\tpath: [],\n\t// \t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t// \t\t\t\t})),\n\t// \t\t\t\tjoins,\n\t// \t\t\t\tdistinct,\n\t// \t\t\t}),\n\t// \t\t\t{},\n\t// \t\t\ttableAlias,\n\t// \t\t);\n\t// \t\tselectionForBuild = selection.map((item) =>\n\t// \t\t\tis(item.field, SQL.Aliased)\n\t// \t\t\t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n\t// \t\t\t\t: item\n\t// \t\t);\n\t// \t\tjoins = [];\n\t// \t\tdistinct = undefined;\n\t// \t}\n\n\t// \tconst result = this.buildSelectQuery({\n\t// \t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n\t// \t\tfields: {},\n\t// \t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n\t// \t\t\tpath: [],\n\t// \t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t// \t\t})),\n\t// \t\twhere,\n\t// \t\tlimit,\n\t// \t\toffset,\n\t// \t\tjoins,\n\t// \t\torderBy,\n\t// \t\tdistinct,\n\t// \t});\n\n\t// \treturn {\n\t// \t\ttableTsKey: tableConfig.tsName,\n\t// \t\tsql: result,\n\t// \t\tselection,\n\t// \t};\n\t// }\n\n\tbuildRelationalQueryWithoutPK({\n\t\tfullSchema,\n\t\tschema,\n\t\ttableNamesMap,\n\t\ttable,\n\t\ttableConfig,\n\t\tqueryConfig: config,\n\t\ttableAlias,\n\t\tnestedQueryRelation,\n\t\tjoinOn,\n\t}: {\n\t\tfullSchema: Record<string, unknown>;\n\t\tschema: TablesRelationalConfig;\n\t\ttableNamesMap: Record<string, string>;\n\t\ttable: PgTable;\n\t\ttableConfig: TableRelationalConfig;\n\t\tqueryConfig: true | DBQueryConfig<'many', true>;\n\t\ttableAlias: string;\n\t\tnestedQueryRelation?: Relation;\n\t\tjoinOn?: SQL;\n\t}): BuildRelationalQueryResult<PgTable, PgColumn> {\n\t\tlet selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\t\tlet limit, offset, orderBy: NonNullable<PgSelectConfig['orderBy']> = [], where;\n\t\tconst joins: PgSelectJoinConfig[] = [];\n\n\t\tif (config === true) {\n\t\t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t\t\tselection = selectionEntries.map((\n\t\t\t\t[key, value],\n\t\t\t) => ({\n\t\t\t\tdbKey: value.name,\n\t\t\t\ttsKey: key,\n\t\t\t\tfield: aliasedTableColumn(value as PgColumn, tableAlias),\n\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\tisJson: false,\n\t\t\t\tselection: [],\n\t\t\t}));\n\t\t} else {\n\t\t\tconst aliasedColumns = Object.fromEntries(\n\t\t\t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t\t\t);\n\n\t\t\tif (config.where) {\n\t\t\t\tconst whereSql = typeof config.where === 'function'\n\t\t\t\t\t? config.where(aliasedColumns, getOperators())\n\t\t\t\t\t: config.where;\n\t\t\t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t\t\t}\n\n\t\t\tconst fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased }[] = [];\n\t\t\tlet selectedColumns: string[] = [];\n\n\t\t\t// Figure out which columns to select\n\t\t\tif (config.columns) {\n\t\t\t\tlet isIncludeMode = false;\n\n\t\t\t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field in tableConfig.columns) {\n\t\t\t\t\t\tif (!isIncludeMode && value === true) {\n\t\t\t\t\t\t\tisIncludeMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectedColumns.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedColumns.length > 0) {\n\t\t\t\t\tselectedColumns = isIncludeMode\n\t\t\t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t\t\t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Select all columns if selection is not specified\n\t\t\t\tselectedColumns = Object.keys(tableConfig.columns);\n\t\t\t}\n\n\t\t\tfor (const field of selectedColumns) {\n\t\t\t\tconst column = tableConfig.columns[field]! as PgColumn;\n\t\t\t\tfieldsSelection.push({ tsKey: field, value: column });\n\t\t\t}\n\n\t\t\tlet selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | DBQueryConfig<'many', false>;\n\t\t\t\trelation: Relation;\n\t\t\t}[] = [];\n\n\t\t\t// Figure out which relations to select\n\t\t\tif (config.with) {\n\t\t\t\tselectedRelations = Object.entries(config.with)\n\t\t\t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t\t\t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t\t\t}\n\n\t\t\tlet extras;\n\n\t\t\t// Figure out which extras to select\n\t\t\tif (config.extras) {\n\t\t\t\textras = typeof config.extras === 'function'\n\t\t\t\t\t? config.extras(aliasedColumns, { sql })\n\t\t\t\t\t: config.extras;\n\t\t\t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t\t\t\t\tfieldsSelection.push({\n\t\t\t\t\t\ttsKey,\n\t\t\t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform `fieldsSelection` into `selection`\n\t\t\t// `fieldsSelection` shouldn't be used after this point\n\t\t\tfor (const { tsKey, value } of fieldsSelection) {\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t\t\t\t\ttsKey,\n\t\t\t\t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\t\tisJson: false,\n\t\t\t\t\tselection: [],\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet orderByOrig = typeof config.orderBy === 'function'\n\t\t\t\t? config.orderBy(aliasedColumns, getOrderByOperators())\n\t\t\t\t: config.orderBy ?? [];\n\t\t\tif (!Array.isArray(orderByOrig)) {\n\t\t\t\torderByOrig = [orderByOrig];\n\t\t\t}\n\t\t\torderBy = orderByOrig.map((orderByValue) => {\n\t\t\t\tif (is(orderByValue, Column)) {\n\t\t\t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as PgColumn;\n\t\t\t\t}\n\t\t\t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t\t\t});\n\n\t\t\tlimit = config.limit;\n\t\t\toffset = config.offset;\n\n\t\t\t// Process all relations\n\t\t\tfor (\n\t\t\t\tconst {\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tqueryConfig: selectedRelationConfigValue,\n\t\t\t\t\trelation,\n\t\t\t\t} of selectedRelations\n\t\t\t) {\n\t\t\t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t\t\t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t\t\t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t\t\t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t\t\t\tconst joinOn = and(\n\t\t\t\t\t...normalizedRelation.fields.map((field, i) =>\n\t\t\t\t\t\teq(\n\t\t\t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t\t\t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tconst builtRelation = this.buildRelationalQueryWithoutPK({\n\t\t\t\t\tfullSchema,\n\t\t\t\t\tschema,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t\t\t\t\ttableConfig: schema[relationTableTsName]!,\n\t\t\t\t\tqueryConfig: is(relation, One)\n\t\t\t\t\t\t? (selectedRelationConfigValue === true\n\t\t\t\t\t\t\t? { limit: 1 }\n\t\t\t\t\t\t\t: { ...selectedRelationConfigValue, limit: 1 })\n\t\t\t\t\t\t: selectedRelationConfigValue,\n\t\t\t\t\ttableAlias: relationTableAlias,\n\t\t\t\t\tjoinOn,\n\t\t\t\t\tnestedQueryRelation: relation,\n\t\t\t\t});\n\t\t\t\tconst field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);\n\t\t\t\tjoins.push({\n\t\t\t\t\ton: sql`true`,\n\t\t\t\t\ttable: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),\n\t\t\t\t\talias: relationTableAlias,\n\t\t\t\t\tjoinType: 'left',\n\t\t\t\t\tlateral: true,\n\t\t\t\t});\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: selectedRelationTsKey,\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tfield,\n\t\t\t\t\trelationTableTsKey: relationTableTsName,\n\t\t\t\t\tisJson: true,\n\t\t\t\t\tselection: builtRelation.selection,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length === 0) {\n\t\t\tthrow new DrizzleError({ message: `No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")` });\n\t\t}\n\n\t\tlet result;\n\n\t\twhere = and(joinOn, where);\n\n\t\tif (nestedQueryRelation) {\n\t\t\tlet field = sql`json_build_array(${\n\t\t\t\tsql.join(\n\t\t\t\t\tselection.map(({ field, tsKey, isJson }) =>\n\t\t\t\t\t\tisJson\n\t\t\t\t\t\t\t? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier('data')}`\n\t\t\t\t\t\t\t: is(field, SQL.Aliased)\n\t\t\t\t\t\t\t? field.sql\n\t\t\t\t\t\t\t: field\n\t\t\t\t\t),\n\t\t\t\t\tsql`, `,\n\t\t\t\t)\n\t\t\t})`;\n\t\t\tif (is(nestedQueryRelation, Many)) {\n\t\t\t\tfield = sql`coalesce(json_agg(${field}${\n\t\t\t\t\torderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined\n\t\t\t\t}), '[]'::json)`;\n\t\t\t\t// orderBy = [];\n\t\t\t}\n\t\t\tconst nestedSelection = [{\n\t\t\t\tdbKey: 'data',\n\t\t\t\ttsKey: 'data',\n\t\t\t\tfield: field.as('data'),\n\t\t\t\tisJson: true,\n\t\t\t\trelationTableTsKey: tableConfig.tsName,\n\t\t\t\tselection,\n\t\t\t}];\n\n\t\t\tconst needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;\n\n\t\t\tif (needsSubquery) {\n\t\t\t\tresult = this.buildSelectQuery({\n\t\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\t\tfields: {},\n\t\t\t\t\tfieldsFlat: [{\n\t\t\t\t\t\tpath: [],\n\t\t\t\t\t\tfield: sql.raw('*'),\n\t\t\t\t\t}],\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset,\n\t\t\t\t\torderBy,\n\t\t\t\t\tsetOperators: [],\n\t\t\t\t});\n\n\t\t\t\twhere = undefined;\n\t\t\t\tlimit = undefined;\n\t\t\t\toffset = undefined;\n\t\t\t\torderBy = [];\n\t\t\t} else {\n\t\t\t\tresult = aliasedTable(table, tableAlias);\n\t\t\t}\n\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: nestedSelection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: selection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttableTsKey: tableConfig.tsName,\n\t\t\tsql: result,\n\t\t\tselection,\n\t\t};\n\t}\n}\n", "import { ColumnAliasProxyHandler, TableAliasProxyHandler } from './alias.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { SQL, View } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class SelectionProxyHandler<T extends Subquery | Record<string, unknown> | View>\n\timplements ProxyHandler<Subquery | Record<string, unknown> | View>\n{\n\tstatic readonly [entityKind]: string = 'SelectionProxyHandler';\n\n\tprivate config: {\n\t\t/**\n\t\t * Table alias for the columns\n\t\t */\n\t\talias?: string;\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL.Aliased` and it's not a selection field (from a subquery)\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `alias` - return the field alias\n\t\t */\n\t\tsqlAliasedBehavior: 'sql' | 'alias';\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL` and it doesn't have an alias declared\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `error` - return a DrizzleTypeError on type level and throw an error on runtime\n\t\t */\n\t\tsqlBehavior: 'sql' | 'error';\n\n\t\t/**\n\t\t * Whether to replace the original name of the column with the alias\n\t\t * Should be set to `true` for views creation\n\t\t * @default false\n\t\t */\n\t\treplaceOriginalName?: boolean;\n\t};\n\n\tconstructor(config: SelectionProxyHandler<T>['config']) {\n\t\tthis.config = { ...config };\n\t}\n\n\tget(subquery: T, prop: string | symbol): any {\n\t\tif (prop === '_') {\n\t\t\treturn {\n\t\t\t\t...subquery['_' as keyof typeof subquery],\n\t\t\t\tselectedFields: new Proxy(\n\t\t\t\t\t(subquery as Subquery)._.selectedFields,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...subquery[ViewBaseConfig as keyof typeof subquery],\n\t\t\t\tselectedFields: new Proxy(\n\t\t\t\t\t(subquery as View)[ViewBaseConfig].selectedFields,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (typeof prop === 'symbol') {\n\t\t\treturn subquery[prop as keyof typeof subquery];\n\t\t}\n\n\t\tconst columns = is(subquery, Subquery)\n\t\t\t? subquery._.selectedFields\n\t\t\t: is(subquery, View)\n\t\t\t? subquery[ViewBaseConfig].selectedFields\n\t\t\t: subquery;\n\t\tconst value: unknown = columns[prop as keyof typeof columns];\n\n\t\tif (is(value, SQL.Aliased)) {\n\t\t\t// Never return the underlying SQL expression for a field previously selected in a subquery\n\t\t\tif (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {\n\t\t\t\treturn value.sql;\n\t\t\t}\n\n\t\t\tconst newValue = value.clone();\n\t\t\tnewValue.isSelectionField = true;\n\t\t\treturn newValue;\n\t\t}\n\n\t\tif (is(value, SQL)) {\n\t\t\tif (this.config.sqlBehavior === 'sql') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`You tried to reference \"${prop}\" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using \".as('alias')\" method.`,\n\t\t\t);\n\t\t}\n\n\t\tif (is(value, Column)) {\n\t\t\tif (this.config.alias) {\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tvalue,\n\t\t\t\t\tnew ColumnAliasProxyHandler(\n\t\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\t\tvalue.table,\n\t\t\t\t\t\t\tnew TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn new Proxy(value, new SelectionProxyHandler(this.config));\n\t}\n}\n", "import { entityKind } from '~/entity.ts';\nimport type { SQL, SQLWrapper } from '~/sql/index.ts';\n\nexport abstract class TypedQueryBuilder<TSelection, TResult = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'TypedQueryBuilder';\n\n\tdeclare _: {\n\t\tselectedFields: TSelection;\n\t\tresult: TResult;\n\t};\n\n\t/** @internal */\n\tgetSelectedFields(): TSelection {\n\t\treturn this._.selectedFields;\n\t}\n\n\tabstract getSQL(): SQL;\n}\n", "import { entityKind, is } from '~/entity.ts';\nimport type { PgColumn } from '~/pg-core/columns/index.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { PgSession, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport type { SubqueryWithSelection } from '~/pg-core/subquery.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport { PgViewBase } from '~/pg-core/view-base.ts';\nimport { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tBuildSubquerySelection,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n\tSetOperator,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { SQL, View } from '~/sql/sql.ts';\nimport type { ColumnsSelection, Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { tracer } from '~/tracing.ts';\nimport { applyMixins, getTableColumns, getTableLikeName, haveSameKeys, type ValueOrArray } from '~/utils.ts';\nimport { orderSelectedFields } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type {\n\tAnyPgSelect,\n\tCreatePgSelectFromBuilderMode,\n\tGetPgSetOperators,\n\tLockConfig,\n\tLockStrength,\n\tPgCreateSetOperatorFn,\n\tPgJoinFn,\n\tPgSelectConfig,\n\tPgSelectDynamic,\n\tPgSelectHKT,\n\tPgSelectHKTBase,\n\tPgSelectPrepare,\n\tPgSelectWithout,\n\tPgSetOperatorExcludedMethods,\n\tPgSetOperatorWithResult,\n\tSelectedFields,\n\tSetOperatorRightSelect,\n} from './select.types.ts';\n\nexport class PgSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n\tTBuilderMode extends 'db' | 'qb' = 'db',\n> {\n\tstatic readonly [entityKind]: string = 'PgSelectBuilder';\n\n\tprivate fields: TSelection;\n\tprivate session: PgSession | undefined;\n\tprivate dialect: PgDialect;\n\tprivate withList: Subquery[] = [];\n\tprivate distinct: boolean | {\n\t\ton: (PgColumn | SQLWrapper)[];\n\t} | undefined;\n\n\tconstructor(\n\t\tconfig: {\n\t\t\tfields: TSelection;\n\t\t\tsession: PgSession | undefined;\n\t\t\tdialect: PgDialect;\n\t\t\twithList?: Subquery[];\n\t\t\tdistinct?: boolean | {\n\t\t\t\ton: (PgColumn | SQLWrapper)[];\n\t\t\t};\n\t\t},\n\t) {\n\t\tthis.fields = config.fields;\n\t\tthis.session = config.session;\n\t\tthis.dialect = config.dialect;\n\t\tif (config.withList) {\n\t\t\tthis.withList = config.withList;\n\t\t}\n\t\tthis.distinct = config.distinct;\n\t}\n\n\t/**\n\t * Specify the table, subquery, or other target that you're\n\t * building a select query against.\n\t *\n\t * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}\n\t */\n\tfrom<TFrom extends PgTable | Subquery | PgViewBase | SQL>(\n\t\tsource: TFrom,\n\t): CreatePgSelectFromBuilderMode<\n\t\tTBuilderMode,\n\t\tGetSelectTableName<TFrom>,\n\t\tTSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection,\n\t\tTSelection extends undefined ? 'single' : 'partial'\n\t> {\n\t\tconst isPartialSelect = !!this.fields;\n\n\t\tlet fields: SelectedFields;\n\t\tif (this.fields) {\n\t\t\tfields = this.fields;\n\t\t} else if (is(source, Subquery)) {\n\t\t\t// This is required to use the proxy handler to get the correct field values from the subquery\n\t\t\tfields = Object.fromEntries(\n\t\t\t\tObject.keys(source._.selectedFields).map((\n\t\t\t\t\tkey,\n\t\t\t\t) => [key, source[key as unknown as keyof typeof source] as unknown as SelectedFields[string]]),\n\t\t\t);\n\t\t} else if (is(source, PgViewBase)) {\n\t\t\tfields = source[ViewBaseConfig].selectedFields as SelectedFields;\n\t\t} else if (is(source, SQL)) {\n\t\t\tfields = {};\n\t\t} else {\n\t\t\tfields = getTableColumns<PgTable>(source);\n\t\t}\n\n\t\treturn new PgSelectBase({\n\t\t\ttable: source,\n\t\t\tfields,\n\t\t\tisPartialSelect,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\twithList: this.withList,\n\t\t\tdistinct: this.distinct,\n\t\t}) as any;\n\t}\n}\n\nexport abstract class PgSelectQueryBuilderBase<\n\tTHKT extends PgSelectHKTBase,\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends TypedQueryBuilder<TSelectedFields, TResult> {\n\tstatic readonly [entityKind]: string = 'PgSelectQueryBuilder';\n\n\toverride readonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly hkt: THKT;\n\t\treadonly tableName: TTableName;\n\t\treadonly selection: TSelection;\n\t\treadonly selectMode: TSelectMode;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t};\n\n\tprotected config: PgSelectConfig;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprivate tableName: string | undefined;\n\tprivate isPartialSelect: boolean;\n\tprotected session: PgSession | undefined;\n\tprotected dialect: PgDialect;\n\n\tconstructor(\n\t\t{ table, fields, isPartialSelect, session, dialect, withList, distinct }: {\n\t\t\ttable: PgSelectConfig['table'];\n\t\t\tfields: PgSelectConfig['fields'];\n\t\t\tisPartialSelect: boolean;\n\t\t\tsession: PgSession | undefined;\n\t\t\tdialect: PgDialect;\n\t\t\twithList: Subquery[];\n\t\t\tdistinct: boolean | {\n\t\t\t\ton: (PgColumn | SQLWrapper)[];\n\t\t\t} | undefined;\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis.config = {\n\t\t\twithList,\n\t\t\ttable,\n\t\t\tfields: { ...fields },\n\t\t\tdistinct,\n\t\t\tsetOperators: [],\n\t\t};\n\t\tthis.isPartialSelect = isPartialSelect;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\t\tthis._ = {\n\t\t\tselectedFields: fields as TSelectedFields,\n\t\t} as this['_'];\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): PgJoinFn<this, TDynamic, TJoinType> {\n\t\treturn (\n\t\t\ttable: PgTable | Subquery | PgViewBase | SQL,\n\t\t\ton: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst baseTableName = this.tableName;\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (!this.isPartialSelect) {\n\t\t\t\t// If this is the first join and this is not a partial select and we're not selecting from raw SQL, \"move\" the fields from the main table to the nested object\n\t\t\t\tif (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {\n\t\t\t\t\tthis.config.fields = {\n\t\t\t\t\t\t[baseTableName]: this.config.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof tableName === 'string' && !is(table, SQL)) {\n\t\t\t\t\tconst selection = is(table, Subquery)\n\t\t\t\t\t\t? table._.selectedFields\n\t\t\t\t\t\t: is(table, View)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields\n\t\t\t\t\t\t: table[Table.Symbol.Columns];\n\t\t\t\t\tthis.config.fields[tableName] = selection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.fields,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as TSelection,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!this.config.joins) {\n\t\t\t\tthis.config.joins = [];\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Executes a `left join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tleftJoin = this.createJoin('left');\n\n\t/**\n\t * Executes a `right join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\trightJoin = this.createJoin('right');\n\n\t/**\n\t * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tinnerJoin = this.createJoin('inner');\n\n\t/**\n\t * Executes a `full join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tfullJoin = this.createJoin('full');\n\n\tprivate createSetOperator(\n\t\ttype: SetOperator,\n\t\tisAll: boolean,\n\t): <TValue extends PgSetOperatorWithResult<TResult>>(\n\t\trightSelection:\n\t\t\t| ((setOperators: GetPgSetOperators) => SetOperatorRightSelect<TValue, TResult>)\n\t\t\t| SetOperatorRightSelect<TValue, TResult>,\n\t) => PgSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tPgSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\treturn (rightSelection) => {\n\t\t\tconst rightSelect = (typeof rightSelection === 'function'\n\t\t\t\t? rightSelection(getPgSetOperators())\n\t\t\t\t: rightSelection) as TypedQueryBuilder<\n\t\t\t\t\tany,\n\t\t\t\t\tTResult\n\t\t\t\t>;\n\n\t\t\tif (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.setOperators.push({ type, isAll, rightSelect });\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Adds `union` set operator to the query.\n\t *\n\t * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique names from customers and users tables\n\t * await db.select({ name: users.name })\n\t *   .from(users)\n\t *   .union(\n\t *     db.select({ name: customers.name }).from(customers)\n\t *   );\n\t * // or\n\t * import { union } from 'drizzle-orm/pg-core'\n\t *\n\t * await union(\n\t *   db.select({ name: users.name }).from(users),\n\t *   db.select({ name: customers.name }).from(customers)\n\t * );\n\t * ```\n\t */\n\tunion = this.createSetOperator('union', false);\n\n\t/**\n\t * Adds `union all` set operator to the query.\n\t *\n\t * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all transaction ids from both online and in-store sales\n\t * await db.select({ transaction: onlineSales.transactionId })\n\t *   .from(onlineSales)\n\t *   .unionAll(\n\t *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t *   );\n\t * // or\n\t * import { unionAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await unionAll(\n\t *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n\t *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t * );\n\t * ```\n\t */\n\tunionAll = this.createSetOperator('union', true);\n\n\t/**\n\t * Adds `intersect` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select course names that are offered in both departments A and B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .intersect(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { intersect } from 'drizzle-orm/pg-core'\n\t *\n\t * await intersect(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tintersect = this.createSetOperator('intersect', false);\n\n\t/**\n\t * Adds `intersect all` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets including all duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all products and quantities that are ordered by both regular and VIP customers\n\t * await db.select({\n\t *   productId: regularCustomerOrders.productId,\n\t *   quantityOrdered: regularCustomerOrders.quantityOrdered\n\t * })\n\t * .from(regularCustomerOrders)\n\t * .intersectAll(\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * // or\n\t * import { intersectAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await intersectAll(\n\t *   db.select({\n\t *     productId: regularCustomerOrders.productId,\n\t *     quantityOrdered: regularCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(regularCustomerOrders),\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * ```\n\t */\n\tintersectAll = this.createSetOperator('intersect', true);\n\n\t/**\n\t * Adds `except` set operator to the query.\n\t *\n\t * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .except(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { except } from 'drizzle-orm/pg-core'\n\t *\n\t * await except(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\texcept = this.createSetOperator('except', false);\n\n\t/**\n\t * Adds `except all` set operator to the query.\n\t *\n\t * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all products that are ordered by regular customers but not by VIP customers\n\t * await db.select({\n\t *   productId: regularCustomerOrders.productId,\n\t *   quantityOrdered: regularCustomerOrders.quantityOrdered,\n\t * })\n\t * .from(regularCustomerOrders)\n\t * .exceptAll(\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered,\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * // or\n\t * import { exceptAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await exceptAll(\n\t *   db.select({\n\t *     productId: regularCustomerOrders.productId,\n\t *     quantityOrdered: regularCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(regularCustomerOrders),\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * ```\n\t */\n\texceptAll = this.createSetOperator('except', true);\n\n\t/** @internal */\n\taddSetOperators(setOperators: PgSelectConfig['setOperators']): PgSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tPgSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\tthis.config.setOperators.push(...setOperators);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be selected.\n\t *\n\t * ```ts\n\t * // Select all cars with green color\n\t * await db.select().from(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Select all BMW cars with a green color\n\t * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Select all cars with the green or blue color\n\t * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(\n\t\twhere: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): PgSelectWithout<this, TDynamic, 'where'> {\n\t\tif (typeof where === 'function') {\n\t\t\twhere = where(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `having` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @param having the `having` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all brands with more than one car\n\t * await db.select({\n\t * \tbrand: cars.brand,\n\t * \tcount: sql<number>`cast(count(${cars.id}) as int)`,\n\t * })\n\t *   .from(cars)\n\t *   .groupBy(cars.brand)\n\t *   .having(({ count }) => gt(count, 1));\n\t * ```\n\t */\n\thaving(\n\t\thaving: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): PgSelectWithout<this, TDynamic, 'having'> {\n\t\tif (typeof having === 'function') {\n\t\t\thaving = having(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.having = having;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `group by` clause to the query.\n\t *\n\t * Calling this method will group rows that have the same values into summary rows, often used for aggregation purposes.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Group and count people by their last names\n\t * await db.select({\n\t *    lastName: people.lastName,\n\t *    count: sql<number>`cast(count(*) as int)`\n\t * })\n\t *   .from(people)\n\t *   .groupBy(people.lastName);\n\t * ```\n\t */\n\tgroupBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>,\n\t): PgSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(...columns: (PgColumn | SQL | SQL.Aliased)[]): PgSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>]\n\t\t\t| (PgColumn | SQL | SQL.Aliased)[]\n\t): PgSelectWithout<this, TDynamic, 'groupBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst groupBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t\tthis.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n\t\t} else {\n\t\t\tthis.config.groupBy = columns as (PgColumn | SQL | SQL.Aliased)[];\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `order by` clause to the query.\n\t *\n\t * Calling this method will sort the result-set in ascending or descending order. By default, the sort order is ascending.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#order-by}\n\t *\n\t * @example\n\t *\n\t * ```\n\t * // Select cars ordered by year\n\t * await db.select().from(cars).orderBy(cars.year);\n\t * ```\n\t *\n\t * You can specify whether results are in ascending or descending order with the `asc()` and `desc()` operators.\n\t *\n\t * ```ts\n\t * // Select cars ordered by year in descending order\n\t * await db.select().from(cars).orderBy(desc(cars.year));\n\t *\n\t * // Select cars ordered by year and price\n\t * await db.select().from(cars).orderBy(asc(cars.year), desc(cars.price));\n\t * ```\n\t */\n\torderBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>,\n\t): PgSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (PgColumn | SQL | SQL.Aliased)[]): PgSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>]\n\t\t\t| (PgColumn | SQL | SQL.Aliased)[]\n\t): PgSelectWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t} else {\n\t\t\tconst orderByArray = columns as (PgColumn | SQL | SQL.Aliased)[];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `limit` clause to the query.\n\t *\n\t * Calling this method will set the maximum number of rows that will be returned by this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param limit the `limit` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the first 10 people from this query.\n\t * await db.select().from(people).limit(10);\n\t * ```\n\t */\n\tlimit(limit: number | Placeholder): PgSelectWithout<this, TDynamic, 'limit'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.limit = limit;\n\t\t} else {\n\t\t\tthis.config.limit = limit;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `offset` clause to the query.\n\t *\n\t * Calling this method will skip a number of rows when returning results from this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param offset the `offset` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the 10th-20th people from this query.\n\t * await db.select().from(people).offset(10).limit(10);\n\t * ```\n\t */\n\toffset(offset: number | Placeholder): PgSelectWithout<this, TDynamic, 'offset'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.offset = offset;\n\t\t} else {\n\t\t\tthis.config.offset = offset;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `for` clause to the query.\n\t *\n\t * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.\n\t *\n\t * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}\n\t *\n\t * @param strength the lock strength.\n\t * @param config the lock configuration.\n\t */\n\tfor(strength: LockStrength, config: LockConfig = {}): PgSelectWithout<this, TDynamic, 'for'> {\n\t\tthis.config.lockingClause = { strength, config };\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildSelectQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tas<TAlias extends string>(\n\t\talias: TAlias,\n\t): SubqueryWithSelection<this['_']['selectedFields'], TAlias> {\n\t\treturn new Proxy(\n\t\t\tnew Subquery(this.getSQL(), this.config.fields, alias),\n\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as SubqueryWithSelection<this['_']['selectedFields'], TAlias>;\n\t}\n\n\t/** @internal */\n\toverride getSelectedFields(): this['_']['selectedFields'] {\n\t\treturn new Proxy(\n\t\t\tthis.config.fields,\n\t\t\tnew SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): PgSelectDynamic<this> {\n\t\treturn this;\n\t}\n}\n\nexport interface PgSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends\n\tPgSelectQueryBuilderBase<\n\t\tPgSelectHKT,\n\t\tTTableName,\n\t\tTSelection,\n\t\tTSelectMode,\n\t\tTNullabilityMap,\n\t\tTDynamic,\n\t\tTExcludedMethods,\n\t\tTResult,\n\t\tTSelectedFields\n\t>,\n\tQueryPromise<TResult>,\n\tSQLWrapper\n{}\n\nexport class PgSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends PgSelectQueryBuilderBase<\n\tPgSelectHKT,\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> implements RunnableQuery<TResult, 'pg'>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'PgSelect';\n\n\t/** @internal */\n\t_prepare(name?: string): PgSelectPrepare<this> {\n\t\tconst { session, config, dialect, joinsNotNullableMap } = this;\n\t\tif (!session) {\n\t\t\tthrow new Error('Cannot execute a query on a query builder. Please use a database instance instead.');\n\t\t}\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\tconst fieldsList = orderSelectedFields<PgColumn>(config.fields);\n\t\t\tconst query = session.prepareQuery<\n\t\t\t\tPreparedQueryConfig & { execute: TResult }\n\t\t\t>(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true);\n\t\t\tquery.joinsNotNullableMap = joinsNotNullableMap;\n\t\t\treturn query;\n\t\t});\n\t}\n\n\t/**\n\t * Create a prepared statement for this query. This allows\n\t * the database to remember this query for the given session\n\t * and call it by name, rather than specifying the full query.\n\t *\n\t * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}\n\t */\n\tprepare(name: string): PgSelectPrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\texecute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t};\n}\n\napplyMixins(PgSelectBase, [QueryPromise]);\n\nfunction createSetOperator(type: SetOperator, isAll: boolean): PgCreateSetOperatorFn {\n\treturn (leftSelect, rightSelect, ...restSelects) => {\n\t\tconst setOperators = [rightSelect, ...restSelects].map((select) => ({\n\t\t\ttype,\n\t\t\tisAll,\n\t\t\trightSelect: select as AnyPgSelect,\n\t\t}));\n\n\t\tfor (const setOperator of setOperators) {\n\t\t\tif (!haveSameKeys((leftSelect as any).getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn (leftSelect as AnyPgSelect).addSetOperators(setOperators) as any;\n\t};\n}\n\nconst getPgSetOperators = () => ({\n\tunion,\n\tunionAll,\n\tintersect,\n\tintersectAll,\n\texcept,\n\texceptAll,\n});\n\n/**\n * Adds `union` set operator to the query.\n *\n * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n *\n * @example\n *\n * ```ts\n * // Select all unique names from customers and users tables\n * import { union } from 'drizzle-orm/pg-core'\n *\n * await union(\n *   db.select({ name: users.name }).from(users),\n *   db.select({ name: customers.name }).from(customers)\n * );\n * // or\n * await db.select({ name: users.name })\n *   .from(users)\n *   .union(\n *     db.select({ name: customers.name }).from(customers)\n *   );\n * ```\n */\nexport const union = createSetOperator('union', false);\n\n/**\n * Adds `union all` set operator to the query.\n *\n * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n *\n * @example\n *\n * ```ts\n * // Select all transaction ids from both online and in-store sales\n * import { unionAll } from 'drizzle-orm/pg-core'\n *\n * await unionAll(\n *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n * );\n * // or\n * await db.select({ transaction: onlineSales.transactionId })\n *   .from(onlineSales)\n *   .unionAll(\n *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n *   );\n * ```\n */\nexport const unionAll = createSetOperator('union', true);\n\n/**\n * Adds `intersect` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n *\n * @example\n *\n * ```ts\n * // Select course names that are offered in both departments A and B\n * import { intersect } from 'drizzle-orm/pg-core'\n *\n * await intersect(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .intersect(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const intersect = createSetOperator('intersect', false);\n\n/**\n * Adds `intersect all` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets including all duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}\n *\n * @example\n *\n * ```ts\n * // Select all products and quantities that are ordered by both regular and VIP customers\n * import { intersectAll } from 'drizzle-orm/pg-core'\n *\n * await intersectAll(\n *   db.select({\n *     productId: regularCustomerOrders.productId,\n *     quantityOrdered: regularCustomerOrders.quantityOrdered\n *   })\n *   .from(regularCustomerOrders),\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * // or\n * await db.select({\n *   productId: regularCustomerOrders.productId,\n *   quantityOrdered: regularCustomerOrders.quantityOrdered\n * })\n * .from(regularCustomerOrders)\n * .intersectAll(\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * ```\n */\nexport const intersectAll = createSetOperator('intersect', true);\n\n/**\n * Adds `except` set operator to the query.\n *\n * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { except } from 'drizzle-orm/pg-core'\n *\n * await except(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .except(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const except = createSetOperator('except', false);\n\n/**\n * Adds `except all` set operator to the query.\n *\n * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}\n *\n * @example\n *\n * ```ts\n * // Select all products that are ordered by regular customers but not by VIP customers\n * import { exceptAll } from 'drizzle-orm/pg-core'\n *\n * await exceptAll(\n *   db.select({\n *     productId: regularCustomerOrders.productId,\n *     quantityOrdered: regularCustomerOrders.quantityOrdered\n *   })\n *   .from(regularCustomerOrders),\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * // or\n * await db.select({\n *   productId: regularCustomerOrders.productId,\n *   quantityOrdered: regularCustomerOrders.quantityOrdered,\n * })\n * .from(regularCustomerOrders)\n * .exceptAll(\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered,\n *   })\n *   .from(vipCustomerOrders)\n * );\n * ```\n */\nexport const exceptAll = createSetOperator('except', true);\n", "import { entityKind } from '~/entity.ts';\nimport { PgDialect } from '~/pg-core/dialect.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection, SQLWrapper } from '~/sql/sql.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport type { PgColumn } from '../columns/index.ts';\nimport type { WithSubqueryWithSelection } from '../subquery.ts';\nimport { PgSelectBuilder } from './select.ts';\nimport type { SelectedFields } from './select.types.ts';\n\nexport class QueryBuilder {\n\tstatic readonly [entityKind]: string = 'PgQueryBuilder';\n\n\tprivate dialect: PgDialect | undefined;\n\n\t$with<TAlias extends string>(alias: TAlias) {\n\t\tconst queryBuilder = this;\n\n\t\treturn {\n\t\t\tas<TSelection extends ColumnsSelection>(\n\t\t\t\tqb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>),\n\t\t\t): WithSubqueryWithSelection<TSelection, TAlias> {\n\t\t\t\tif (typeof qb === 'function') {\n\t\t\t\t\tqb = qb(queryBuilder);\n\t\t\t\t}\n\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tnew WithSubquery(qb.getSQL(), qb.getSelectedFields() as SelectedFields, alias, true),\n\t\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t\t) as WithSubqueryWithSelection<TSelection, TAlias>;\n\t\t\t},\n\t\t};\n\t}\n\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\tfunction select(): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields?: TSelection,\n\t\t): PgSelectBuilder<TSelection | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\tfunction selectDistinct(): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction selectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\tfunction selectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction selectDistinctOn<TSelection extends SelectedFields>(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields: TSelection,\n\t\t): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction selectDistinctOn(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields?: SelectedFields,\n\t\t): PgSelectBuilder<SelectedFields | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\tdistinct: { on },\n\t\t\t});\n\t\t}\n\n\t\treturn { select, selectDistinct, selectDistinctOn };\n\t}\n\n\tselect(): PgSelectBuilder<undefined, 'qb'>;\n\tselect<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\tselect<TSelection extends SelectedFields>(fields?: TSelection): PgSelectBuilder<TSelection | undefined, 'qb'> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t});\n\t}\n\n\tselectDistinct(): PgSelectBuilder<undefined>;\n\tselectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\tselectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\tselectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;\n\tselectDistinctOn<TSelection extends SelectedFields>(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields: TSelection,\n\t): PgSelectBuilder<TSelection>;\n\tselectDistinctOn(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields?: SelectedFields,\n\t): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t\tdistinct: { on },\n\t\t});\n\t}\n\n\t// Lazy load dialect to avoid circular dependency\n\tprivate getDialect() {\n\t\tif (!this.dialect) {\n\t\t\tthis.dialect = new PgDialect();\n\t\t}\n\n\t\treturn this.dialect;\n\t}\n}\n", "import { SQL } from '~/sql/sql.ts';\n\nimport { entityKind, is } from '~/entity.ts';\nimport type { ExtraConfigColumn, PgColumn } from './columns/index.ts';\nimport { IndexedColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\ninterface IndexConfig {\n\tname?: string;\n\n\tcolumns: Partial<IndexedColumn | SQL>[];\n\n\t/**\n\t * If true, the index will be created as `create unique index` instead of `create index`.\n\t */\n\tunique: boolean;\n\n\t/**\n\t * If true, the index will be created as `create index concurrently` instead of `create index`.\n\t */\n\tconcurrently?: boolean;\n\n\t/**\n\t * If true, the index will be created as `create index ... on only <table>` instead of `create index ... on <table>`.\n\t */\n\tonly: boolean;\n\n\t/**\n\t * Condition for partial index.\n\t */\n\twhere?: SQL;\n\n\t/**\n\t * The optional WITH clause specifies storage parameters for the index\n\t */\n\twith?: Record<string, any>;\n\n\t/**\n\t * The optional WITH clause method for the index\n\t */\n\tmethod?: 'btree' | string;\n}\n\nexport type IndexColumn = PgColumn;\n\nexport type PgIndexMethod = 'btree' | 'hash' | 'gist' | 'spgist' | 'gin' | 'brin' | 'hnsw' | 'ivfflat' | (string & {});\n\nexport type PgIndexOpClass =\n\t| 'abstime_ops'\n\t| 'access_method'\n\t| 'anyarray_eq'\n\t| 'anyarray_ge'\n\t| 'anyarray_gt'\n\t| 'anyarray_le'\n\t| 'anyarray_lt'\n\t| 'anyarray_ne'\n\t| 'bigint_ops'\n\t| 'bit_ops'\n\t| 'bool_ops'\n\t| 'box_ops'\n\t| 'bpchar_ops'\n\t| 'char_ops'\n\t| 'cidr_ops'\n\t| 'cstring_ops'\n\t| 'date_ops'\n\t| 'float_ops'\n\t| 'int2_ops'\n\t| 'int4_ops'\n\t| 'int8_ops'\n\t| 'interval_ops'\n\t| 'jsonb_ops'\n\t| 'macaddr_ops'\n\t| 'name_ops'\n\t| 'numeric_ops'\n\t| 'oid_ops'\n\t| 'oidint4_ops'\n\t| 'oidint8_ops'\n\t| 'oidname_ops'\n\t| 'oidvector_ops'\n\t| 'point_ops'\n\t| 'polygon_ops'\n\t| 'range_ops'\n\t| 'record_eq'\n\t| 'record_ge'\n\t| 'record_gt'\n\t| 'record_le'\n\t| 'record_lt'\n\t| 'record_ne'\n\t| 'text_ops'\n\t| 'time_ops'\n\t| 'timestamp_ops'\n\t| 'timestamptz_ops'\n\t| 'timetz_ops'\n\t| 'uuid_ops'\n\t| 'varbit_ops'\n\t| 'varchar_ops'\n\t// pg_vector types\n\t| 'xml_ops'\n\t| 'vector_l2_ops'\n\t| 'vector_ip_ops'\n\t| 'vector_cosine_ops'\n\t| 'vector_l1_ops'\n\t| 'bit_hamming_ops'\n\t| 'bit_jaccard_ops'\n\t| 'halfvec_l2_ops'\n\t| 'sparsevec_l2_op'\n\t| (string & {});\n\nexport class IndexBuilderOn {\n\tstatic readonly [entityKind]: string = 'PgIndexBuilderOn';\n\n\tconstructor(private unique: boolean, private name?: string) {}\n\n\ton(...columns: [Partial<ExtraConfigColumn> | SQL, ...Partial<ExtraConfigColumn>[] | SQL[]]): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\t\t\t\tit = it as ExtraConfigColumn;\n\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(it.name, it.columnType!, it.indexConfig!);\n\t\t\t\tit.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n\t\t\t\treturn clonedIndexedColumn;\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\tfalse,\n\t\t\tthis.name,\n\t\t);\n\t}\n\n\tonOnly(...columns: [Partial<ExtraConfigColumn | SQL>, ...Partial<ExtraConfigColumn>[] | SQL[]]): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\t\t\t\tit = it as ExtraConfigColumn;\n\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(it.name, it.columnType!, it.indexConfig!);\n\t\t\t\tit.indexConfig = it.defaultConfig;\n\t\t\t\treturn clonedIndexedColumn;\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\ttrue,\n\t\t\tthis.name,\n\t\t);\n\t}\n\n\t/**\n\t * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.\n\t *\n\t * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param method The name of the index method to be used\n\t * @param columns\n\t * @returns\n\t */\n\tusing(\n\t\tmethod: PgIndexMethod,\n\t\t...columns: [Partial<ExtraConfigColumn | SQL>, ...Partial<ExtraConfigColumn>[] | SQL[]]\n\t): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\t\t\t\tit = it as ExtraConfigColumn;\n\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(it.name, it.columnType!, it.indexConfig!);\n\t\t\t\tit.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n\t\t\t\treturn clonedIndexedColumn;\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\ttrue,\n\t\t\tthis.name,\n\t\t\tmethod,\n\t\t);\n\t}\n}\n\nexport interface AnyIndexBuilder {\n\tbuild(table: PgTable): Index;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IndexBuilder extends AnyIndexBuilder {}\n\nexport class IndexBuilder implements AnyIndexBuilder {\n\tstatic readonly [entityKind]: string = 'PgIndexBuilder';\n\n\t/** @internal */\n\tconfig: IndexConfig;\n\n\tconstructor(\n\t\tcolumns: Partial<IndexedColumn | SQL>[],\n\t\tunique: boolean,\n\t\tonly: boolean,\n\t\tname?: string,\n\t\tmethod: string = 'btree',\n\t) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tunique,\n\t\t\tonly,\n\t\t\tmethod,\n\t\t};\n\t}\n\n\tconcurrently(): this {\n\t\tthis.config.concurrently = true;\n\t\treturn this;\n\t}\n\n\twith(obj: Record<string, any>): this {\n\t\tthis.config.with = obj;\n\t\treturn this;\n\t}\n\n\twhere(condition: SQL): this {\n\t\tthis.config.where = condition;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): Index {\n\t\treturn new Index(this.config, table);\n\t}\n}\n\nexport class Index {\n\tstatic readonly [entityKind]: string = 'PgIndex';\n\n\treadonly config: IndexConfig & { table: PgTable };\n\n\tconstructor(config: IndexConfig, table: PgTable) {\n\t\tthis.config = { ...config, table };\n\t}\n}\n\nexport type GetColumnsTableName<TColumns> = TColumns extends PgColumn ? TColumns['_']['name']\n\t: TColumns extends PgColumn[] ? TColumns[number]['_']['name']\n\t: never;\n\nexport function index(name?: string): IndexBuilderOn {\n\treturn new IndexBuilderOn(false, name);\n}\n\nexport function uniqueIndex(name?: string): IndexBuilderOn {\n\treturn new IndexBuilderOn(true, name);\n}\n", "export const PgViewConfig = Symbol.for('drizzle:PgViewConfig');\n", "import type { BuildColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { AddAliasToSelection } from '~/query-builders/select.types.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection, SQL } from '~/sql/sql.ts';\nimport { getTableColumns } from '~/utils.ts';\nimport type { PgColumn, PgColumnBuilderBase } from './columns/common.ts';\nimport { QueryBuilder } from './query-builders/query-builder.ts';\nimport type { SelectedFields } from './query-builders/select.types.ts';\nimport { pgTable } from './table.ts';\nimport { PgViewBase } from './view-base.ts';\nimport { PgViewConfig } from './view-common.ts';\n\nexport interface ViewWithConfig {\n\tcheckOption: 'local' | 'cascaded';\n\tsecurityBarrier: boolean;\n\tsecurityInvoker: boolean;\n}\n\nexport class DefaultViewBuilderCore<TConfig extends { name: string; columns?: unknown }> {\n\tstatic readonly [entityKind]: string = 'PgDefaultViewBuilderCore';\n\n\tdeclare readonly _: {\n\t\treadonly name: TConfig['name'];\n\t\treadonly columns: TConfig['columns'];\n\t};\n\n\tconstructor(\n\t\tprotected name: TConfig['name'],\n\t\tprotected schema: string | undefined,\n\t) {}\n\n\tprotected config: {\n\t\twith?: ViewWithConfig;\n\t} = {};\n\n\twith(config: ViewWithConfig): this {\n\t\tthis.config.with = config;\n\t\treturn this;\n\t}\n}\n\nexport class ViewBuilder<TName extends string = string> extends DefaultViewBuilderCore<{ name: TName }> {\n\tstatic readonly [entityKind]: string = 'PgViewBuilder';\n\n\tas<TSelectedFields extends SelectedFields>(\n\t\tqb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>),\n\t): PgViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>> {\n\t\tif (typeof qb === 'function') {\n\t\t\tqb = qb(new QueryBuilder());\n\t\t}\n\t\tconst selectionProxy = new SelectionProxyHandler<TSelectedFields>({\n\t\t\talias: this.name,\n\t\t\tsqlBehavior: 'error',\n\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\treplaceOriginalName: true,\n\t\t});\n\t\tconst aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);\n\t\treturn new Proxy(\n\t\t\tnew PgView({\n\t\t\t\tpgConfig: this.config,\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: aliasedSelection,\n\t\t\t\t\tquery: qb.getSQL().inlineParams(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tselectionProxy as any,\n\t\t) as PgViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>>;\n\t}\n}\n\nexport class ManualViewBuilder<\n\tTName extends string = string,\n\tTColumns extends Record<string, PgColumnBuilderBase> = Record<string, PgColumnBuilderBase>,\n> extends DefaultViewBuilderCore<{ name: TName; columns: TColumns }> {\n\tstatic readonly [entityKind]: string = 'PgManualViewBuilder';\n\n\tprivate columns: Record<string, PgColumn>;\n\n\tconstructor(\n\t\tname: TName,\n\t\tcolumns: TColumns,\n\t\tschema: string | undefined,\n\t) {\n\t\tsuper(name, schema);\n\t\tthis.columns = getTableColumns(pgTable(name, columns));\n\t}\n\n\texisting(): PgViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>> {\n\t\treturn new Proxy(\n\t\t\tnew PgView({\n\t\t\t\tpgConfig: undefined,\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: this.columns,\n\t\t\t\t\tquery: undefined,\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew SelectionProxyHandler({\n\t\t\t\talias: this.name,\n\t\t\t\tsqlBehavior: 'error',\n\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\treplaceOriginalName: true,\n\t\t\t}),\n\t\t) as PgViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>>;\n\t}\n\n\tas(query: SQL): PgViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>> {\n\t\treturn new Proxy(\n\t\t\tnew PgView({\n\t\t\t\tpgConfig: this.config,\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: this.columns,\n\t\t\t\t\tquery: query.inlineParams(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew SelectionProxyHandler({\n\t\t\t\talias: this.name,\n\t\t\t\tsqlBehavior: 'error',\n\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\treplaceOriginalName: true,\n\t\t\t}),\n\t\t) as PgViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>>;\n\t}\n}\n\nexport interface PgMaterializedViewWithConfig {\n\t[Key: string]: string | number | boolean | SQL;\n}\n\nexport class MaterializedViewBuilderCore<TConfig extends { name: string; columns?: unknown }> {\n\tstatic readonly [entityKind]: string = 'PgMaterializedViewBuilderCore';\n\n\tdeclare _: {\n\t\treadonly name: TConfig['name'];\n\t\treadonly columns: TConfig['columns'];\n\t};\n\n\tconstructor(\n\t\tprotected name: TConfig['name'],\n\t\tprotected schema: string | undefined,\n\t) {}\n\n\tprotected config: {\n\t\twith?: PgMaterializedViewWithConfig;\n\t\tusing?: string;\n\t\ttablespace?: string;\n\t\twithNoData?: boolean;\n\t} = {};\n\n\tusing(using: string): this {\n\t\tthis.config.using = using;\n\t\treturn this;\n\t}\n\n\twith(config: PgMaterializedViewWithConfig): this {\n\t\tthis.config.with = config;\n\t\treturn this;\n\t}\n\n\ttablespace(tablespace: string): this {\n\t\tthis.config.tablespace = tablespace;\n\t\treturn this;\n\t}\n\n\twithNoData(): this {\n\t\tthis.config.withNoData = true;\n\t\treturn this;\n\t}\n}\n\nexport class MaterializedViewBuilder<TName extends string = string>\n\textends MaterializedViewBuilderCore<{ name: TName }>\n{\n\tstatic readonly [entityKind]: string = 'PgMaterializedViewBuilder';\n\n\tas<TSelectedFields extends SelectedFields>(\n\t\tqb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>),\n\t): PgMaterializedViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>> {\n\t\tif (typeof qb === 'function') {\n\t\t\tqb = qb(new QueryBuilder());\n\t\t}\n\t\tconst selectionProxy = new SelectionProxyHandler<TSelectedFields>({\n\t\t\talias: this.name,\n\t\t\tsqlBehavior: 'error',\n\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\treplaceOriginalName: true,\n\t\t});\n\t\tconst aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);\n\t\treturn new Proxy(\n\t\t\tnew PgMaterializedView({\n\t\t\t\tpgConfig: {\n\t\t\t\t\twith: this.config.with,\n\t\t\t\t\tusing: this.config.using,\n\t\t\t\t\ttablespace: this.config.tablespace,\n\t\t\t\t\twithNoData: this.config.withNoData,\n\t\t\t\t},\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: aliasedSelection,\n\t\t\t\t\tquery: qb.getSQL().inlineParams(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tselectionProxy as any,\n\t\t) as PgMaterializedViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>>;\n\t}\n}\n\nexport class ManualMaterializedViewBuilder<\n\tTName extends string = string,\n\tTColumns extends Record<string, PgColumnBuilderBase> = Record<string, PgColumnBuilderBase>,\n> extends MaterializedViewBuilderCore<{ name: TName; columns: TColumns }> {\n\tstatic readonly [entityKind]: string = 'PgManualMaterializedViewBuilder';\n\n\tprivate columns: Record<string, PgColumn>;\n\n\tconstructor(\n\t\tname: TName,\n\t\tcolumns: TColumns,\n\t\tschema: string | undefined,\n\t) {\n\t\tsuper(name, schema);\n\t\tthis.columns = getTableColumns(pgTable(name, columns));\n\t}\n\n\texisting(): PgMaterializedViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>> {\n\t\treturn new Proxy(\n\t\t\tnew PgMaterializedView({\n\t\t\t\tpgConfig: undefined,\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: this.columns,\n\t\t\t\t\tquery: undefined,\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew SelectionProxyHandler({\n\t\t\t\talias: this.name,\n\t\t\t\tsqlBehavior: 'error',\n\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\treplaceOriginalName: true,\n\t\t\t}),\n\t\t) as PgMaterializedViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>>;\n\t}\n\n\tas(query: SQL): PgMaterializedViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>> {\n\t\treturn new Proxy(\n\t\t\tnew PgMaterializedView({\n\t\t\t\tpgConfig: undefined,\n\t\t\t\tconfig: {\n\t\t\t\t\tname: this.name,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\tselectedFields: this.columns,\n\t\t\t\t\tquery: query.inlineParams(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnew SelectionProxyHandler({\n\t\t\t\talias: this.name,\n\t\t\t\tsqlBehavior: 'error',\n\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\treplaceOriginalName: true,\n\t\t\t}),\n\t\t) as PgMaterializedViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>>;\n\t}\n}\n\nexport class PgView<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> extends PgViewBase<TName, TExisting, TSelectedFields> {\n\tstatic readonly [entityKind]: string = 'PgView';\n\n\t[PgViewConfig]: {\n\t\twith?: ViewWithConfig;\n\t} | undefined;\n\n\tconstructor({ pgConfig, config }: {\n\t\tpgConfig: {\n\t\t\twith?: ViewWithConfig;\n\t\t} | undefined;\n\t\tconfig: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: SelectedFields;\n\t\t\tquery: SQL | undefined;\n\t\t};\n\t}) {\n\t\tsuper(config);\n\t\tif (pgConfig) {\n\t\t\tthis[PgViewConfig] = {\n\t\t\t\twith: pgConfig.with,\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport type PgViewWithSelection<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> = PgView<TName, TExisting, TSelectedFields> & TSelectedFields;\n\nexport const PgMaterializedViewConfig = Symbol.for('drizzle:PgMaterializedViewConfig');\n\nexport class PgMaterializedView<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> extends PgViewBase<TName, TExisting, TSelectedFields> {\n\tstatic readonly [entityKind]: string = 'PgMaterializedView';\n\n\treadonly [PgMaterializedViewConfig]: {\n\t\treadonly with?: PgMaterializedViewWithConfig;\n\t\treadonly using?: string;\n\t\treadonly tablespace?: string;\n\t\treadonly withNoData?: boolean;\n\t} | undefined;\n\n\tconstructor({ pgConfig, config }: {\n\t\tpgConfig: {\n\t\t\twith: PgMaterializedViewWithConfig | undefined;\n\t\t\tusing: string | undefined;\n\t\t\ttablespace: string | undefined;\n\t\t\twithNoData: boolean | undefined;\n\t\t} | undefined;\n\t\tconfig: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: SelectedFields;\n\t\t\tquery: SQL | undefined;\n\t\t};\n\t}) {\n\t\tsuper(config);\n\t\tthis[PgMaterializedViewConfig] = {\n\t\t\twith: pgConfig?.with,\n\t\t\tusing: pgConfig?.using,\n\t\t\ttablespace: pgConfig?.tablespace,\n\t\t\twithNoData: pgConfig?.withNoData,\n\t\t};\n\t}\n}\n\nexport type PgMaterializedViewWithSelection<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> = PgMaterializedView<TName, TExisting, TSelectedFields> & TSelectedFields;\n\n/** @internal */\nexport function pgViewWithSchema(\n\tname: string,\n\tselection: Record<string, PgColumnBuilderBase> | undefined,\n\tschema: string | undefined,\n): ViewBuilder | ManualViewBuilder {\n\tif (selection) {\n\t\treturn new ManualViewBuilder(name, selection, schema);\n\t}\n\treturn new ViewBuilder(name, schema);\n}\n\n/** @internal */\nexport function pgMaterializedViewWithSchema(\n\tname: string,\n\tselection: Record<string, PgColumnBuilderBase> | undefined,\n\tschema: string | undefined,\n): MaterializedViewBuilder | ManualMaterializedViewBuilder {\n\tif (selection) {\n\t\treturn new ManualMaterializedViewBuilder(name, selection, schema);\n\t}\n\treturn new MaterializedViewBuilder(name, schema);\n}\n\nexport function pgView<TName extends string>(name: TName): ViewBuilder<TName>;\nexport function pgView<TName extends string, TColumns extends Record<string, PgColumnBuilderBase>>(\n\tname: TName,\n\tcolumns: TColumns,\n): ManualViewBuilder<TName, TColumns>;\nexport function pgView(name: string, columns?: Record<string, PgColumnBuilderBase>): ViewBuilder | ManualViewBuilder {\n\treturn pgViewWithSchema(name, columns, undefined);\n}\n\nexport function pgMaterializedView<TName extends string>(name: TName): MaterializedViewBuilder<TName>;\nexport function pgMaterializedView<TName extends string, TColumns extends Record<string, PgColumnBuilderBase>>(\n\tname: TName,\n\tcolumns: TColumns,\n): ManualMaterializedViewBuilder<TName, TColumns>;\nexport function pgMaterializedView(\n\tname: string,\n\tcolumns?: Record<string, PgColumnBuilderBase>,\n): MaterializedViewBuilder | ManualMaterializedViewBuilder {\n\treturn pgMaterializedViewWithSchema(name, columns, undefined);\n}\n", "import { entityKind, is } from '~/entity.ts';\nimport type { pgEnum } from './columns/enum.ts';\nimport { pgEnumWithSchema } from './columns/enum.ts';\nimport { type PgTableFn, pgTableWithSchema } from './table.ts';\nimport { type pgMaterializedView, pgMaterializedViewWithSchema, type pgView, pgViewWithSchema } from './view.ts';\n\nexport class PgSchema<TName extends string = string> {\n\tstatic readonly [entityKind]: string = 'PgSchema';\n\tconstructor(\n\t\tpublic readonly schemaName: TName,\n\t) {}\n\n\ttable: PgTableFn<TName> = ((name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(name, columns, extraConfig, this.schemaName);\n\t});\n\n\tview = ((name, columns) => {\n\t\treturn pgViewWithSchema(name, columns, this.schemaName);\n\t}) as typeof pgView;\n\n\tmaterializedView = ((name, columns) => {\n\t\treturn pgMaterializedViewWithSchema(name, columns, this.schemaName);\n\t}) as typeof pgMaterializedView;\n\n\tenum: typeof pgEnum = ((name, values) => {\n\t\treturn pgEnumWithSchema(name, values, this.schemaName);\n\t});\n}\n\nexport function isPgSchema(obj: unknown): obj is PgSchema {\n\treturn is(obj, PgSchema);\n}\n\nexport function pgSchema<T extends string>(name: T) {\n\tif (name === 'public') {\n\t\tthrow new Error(\n\t\t\t`You can't specify 'public' as schema name. Postgres is using public schema by default. If you want to use 'public' schema, just use pgTable() instead of creating a schema`,\n\t\t);\n\t}\n\n\treturn new PgSchema(name);\n}\n", "import { index, timestamp, uuid, varchar, integer, real, text, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { sql } from 'drizzle-orm';\r\n\r\nexport const postEstateModel = pgSchema(process.env.SCHEMA_POSTGRES || \"\").table(\r\n  'post_estate',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n    /** @title T\u00EAn b\u00E0i \u0111\u0103ng */\r\n    title: varchar('title', { length: 255 }).notNull(),\r\n\r\n    /** @title Remove vn title */\r\n    slug: varchar('slug', { length: 255 }).notNull(),\r\n\r\n    /** @title M\u00E3 b\u00E0i \u0111\u0103ng */\r\n    code: varchar('code', { length: 255 }).notNull(),\r\n\r\n    /** @title \u0110\u1ECBa ch\u1EC9 hi\u1EC3n th\u1ECB tin \u0111\u0103ng */\r\n    address: varchar('title', { length: 255 }),\r\n\r\n    /** @title Th\u00F4ng tin \u0111\u01B0\u1EDDng ph\u1ED1  */\r\n    street: varchar('street', { length: 255 }),\r\n\r\n    lat: real('lat').default(0),\r\n\r\n    lang: real('lang').default(0),\r\n\r\n    /** @title Lo\u1EA1i d\u1EF1 \u00E1n */\r\n    type: integer('type').notNull().default(0),\r\n\r\n    /** @title youtube url */\r\n    youtubeUrl: text('youtube_url'),\r\n\r\n    /** @title \u0110i\u1EC3m b\u00E0i vi\u1EBFt */\r\n    point: real('point').notNull(),\r\n\r\n    /** @title tinh th\u00E0nh */\r\n    provinceCode: integer('province_code').notNull(),\r\n\r\n    /** @title qu\u1EADn huy\u1EC7n */\r\n    districtCode: integer('district_code').notNull(),\r\n\r\n    /** @title ph\u01B0\u1EDDng x\u00E3 */\r\n    wardCode: integer('ward_code').notNull(),\r\n\r\n    /** @title id th\u00F4ng tin ng\u01B0\u1EDDi \u0111\u0103ng */\r\n    customerId: uuid('customer_id').notNull(),\r\n\r\n    /** @title Ghi ch\u00FA cancel b\u00E0i vi\u1EBFt */\r\n    noteVerified: text('note_verified'),\r\n\r\n    /** @title Kh\u00F3a b\u00E0i vi\u1EBFt */\r\n    isBlock: integer('is_block').notNull().default(0),\r\n\r\n    /** @title Un active b\u00E0i vi\u1EBFt */\r\n    isDelete: integer('is_delete').notNull().default(0),\r\n\r\n    /** @title Ch\u1EE7 b\u00E0i vi\u1EBFt */\r\n    isOwner: integer('is_owner').notNull().default(0),\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {\r\n      idxPostEstateNameSlugId: index('post_estate_name_slug_id_idx').on(table.title, table.slug, table.id),\r\n    };\r\n  },\r\n);\r\n", "import { index, timestamp, uuid, varchar, integer, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { sql } from 'drizzle-orm';\r\nimport { postEstateModel } from './postEstate.model';\r\n\r\nexport const imageModel = pgSchema(process.env.SCHEMA_POSTGRES  || '').table(\r\n  'images',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n    link: varchar('link', { length: 255 }).notNull(),\r\n\r\n    type: integer('type').notNull().default(0),\r\n\r\n    position: integer('position').default(0),\r\n\r\n    isAvatar: integer('is_avatar').notNull().default(0),\r\n\r\n    description: varchar('description', { length: 255 }),\r\n\r\n    isUsed: integer('is_used').default(0),\r\n\r\n    postEstateId: uuid('post_estate_id').references(() => postEstateModel.id, {\r\n      onDelete: 'cascade',\r\n      onUpdate: 'cascade'\r\n    }),\r\n\r\n    isConfirmUpdate: integer('is_confirm_update').notNull().default(0),\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {\r\n      idxNameId: index('image_link_id_idx').on(table.link, table.id),\r\n    };\r\n  },\r\n);\r\n", "import { index, timestamp, uuid, varchar, integer, text, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { sql } from 'drizzle-orm';\r\n\r\nexport const commonLandModel = pgSchema(\"bds_products\").table(\r\n  'common_land',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n    name: varchar('name', { length: 255 }).notNull(),\r\n\r\n    code: varchar('code', { length: 255 }).notNull(),\r\n\r\n    slug: varchar('slug', { length: 255 }).notNull(),\r\n\r\n    content: text('content'),\r\n\r\n    provinceCode: integer('province_code').notNull(),\r\n\r\n    districtCode: integer('district_code').notNull(),\r\n\r\n    wardCode: integer('ward_code').notNull(),\r\n\r\n    status: integer('status').default(1),\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {\r\n      idxCommonLandNameSlugId: index('common_land_name_slug_id_idx').on(table.name, table.slug, table.id),\r\n    };\r\n  },\r\n);\r\n", "import { timestamp, uuid, varchar, integer, real, text, numeric, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { postEstateModel } from '.';\r\nimport { sql } from 'drizzle-orm';\r\n\r\nexport const postEstateDetailModel = pgSchema(process.env.SCHEMA_POSTGRES || \"\").table(\r\n  'post_estate_detail',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n\r\n    postEstateId: uuid('post_estate_id').references(() => postEstateModel.id, {\r\n      onDelete: 'cascade',\r\n    }),\r\n\r\n    /** @title N\u1ED9i dung m\u00F4 t\u1EA3 b\u00E0i \u0111\u0103ng */\r\n    content: text('content'),\r\n\r\n    /** @title Di\u1EC7n t\u00EDch*/\r\n    acreage: real('acreage'),\r\n\r\n    /** @title M\u1EB7t ti\u1EC1n nh\u00E0*/\r\n    facade: real('facade'),\r\n\r\n    /** @title \u0110\u01B0\u1EDDng v\u00E0o nh\u00E0 */\r\n    numWayIn: real('num_way_in'),\r\n\r\n    /** @title Gi\u00E1 ti\u1EC1n */\r\n    price: numeric('price'),\r\n\r\n    /** @title \u0110\u01A1n v\u1ECB */\r\n    unit: integer('unit').notNull().default(0),\r\n\r\n    /** @title Gi\u00E1 ti\u1EC1n t\u1EDBi kho\u1EA3n*/\r\n    priceSquareMetre: numeric('price_square_metre'),\r\n\r\n    /** @title H\u01B0\u1EDBng nh\u00E0 */\r\n    directionHouse: varchar('direction_house', { length: 100 }),\r\n\r\n    /** @title H\u01B0\u1EDBng ban c\u00F4ng */\r\n    directionBalcony: varchar('direction_balcony', { length: 100 }),\r\n\r\n    /** @title S\u1ED1  ph\u00F2ng ng\u1EE7 */\r\n    numBedroom: integer('num_bedroom'),\r\n\r\n    /** @title Nh\u00E0 m\u1EB7t ti\u1EC1n */\r\n    numRoadHouse: integer('num_road_House'),\r\n\r\n    /** @title S\u1ED1 t\u1EA7ng */\r\n    numFloors: integer('num_floors'),\r\n\r\n    /** @title S\u1ED1 ph\u00F2ng t\u1EAFm */\r\n    numBathroom: integer('num_bathroom'),\r\n\r\n    /** @title \u0110\u1ED3 n\u1ED9i th\u1EA5t */\r\n    furniture: varchar('furniture', { length: 255 }),\r\n\r\n    /** @title Gi\u1EA5y t\u1EDD ph\u00E1p l\u00FD */\r\n    houseOwningDocument: text('house_owning_document'),\r\n\r\n    /** @title T\u00EAn li\u00EAn h\u1EC7 */\r\n    contactName: varchar('contact_name', { length: 255 }),\r\n\r\n    /** @title S\u1ED1 \u0111i\u1EC7n tho\u1EA1i li\u00EAn h\u1EC7 */\r\n    contactPhone: varchar('contact_phone', { length: 255 }),\r\n\r\n    /** @title Mail li\u00EAn h\u1EC7 */\r\n    contactMail: varchar('contact_mail', { length: 100 }),\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {};\r\n  },\r\n);\r\n", "import { index, timestamp, uuid, varchar, integer, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { sql } from 'drizzle-orm';\r\n\r\nexport const postEstateReportModel = pgSchema(process.env.SCHEMA_POSTGRES || \"\").table(\r\n  'post_estate_report',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n    /** @title M\u00F4 t\u1EA3 n\u1ED9i dung report */\r\n    description: varchar('description', { length: 255 }).notNull(),\r\n\r\n    /** @title id tin \u0111\u0103ng */\r\n    postEstateId: uuid('post_estate_id').notNull(),\r\n\r\n    /** @title id ng\u01B0\u1EDDi report */\r\n    customerId: uuid('customer_id'),\r\n\r\n    /** @title name ng\u01B0\u1EDDi report */\r\n    contactName: varchar('contact_name', { length: 50 }),\r\n\r\n    /** @title phone ng\u01B0\u1EDDi report */\r\n    contactPhone: varchar('contact_phone', { length: 20 }),\r\n\r\n    /** @title email ng\u01B0\u1EDDi report */\r\n    contactMail: varchar('contact_mail', { length: 50 }),\r\n\r\n    /** @title tr\u1EA1ng th\u00E1i x\u1EED l\u00FD */\r\n    isConfirmed: integer('is_confirmed').notNull().default(0),\r\n\r\n    /** @title danh s\u00E1ch id report */\r\n    // @Column({ name: 'parents_id', type: 'varchar', nullable: true, default: null })\r\n    // parentsId: string | null;\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {\r\n      idxPostEstateReportNameId: index('post_estate_report_name_id_idx').on(table.contactName, table.id),\r\n    };\r\n  },\r\n);\r\n", "import { index, timestamp, uuid, varchar, integer, text, pgSchema } from 'drizzle-orm/pg-core';\r\nimport { sql } from 'drizzle-orm';\r\nimport { postEstateModel } from './postEstate.model';\r\n\r\nexport const postEstateHistoryModel = pgSchema(process.env.SCHEMA_POSTGRES || \"\").table(\r\n  'post_estate_history',\r\n  {\r\n    id: uuid('id')\r\n      .default(sql`gen_random_uuid()`)\r\n      .primaryKey(),\r\n\r\n    /** @title id tin \u0111\u0103ng */\r\n    postEstateId: uuid('post_estate_id')\r\n      .notNull()\r\n      .references(() => postEstateModel.id, {\r\n        onDelete: 'cascade',\r\n        onUpdate: 'cascade',\r\n      }),\r\n\r\n    note: text('node'),\r\n\r\n    createdBy: varchar('created_by', { length: 255 }),\r\n\r\n    createdAt: timestamp('created_at')\r\n      .notNull()\r\n      .default(sql`now()`),\r\n\r\n    modifyBy: varchar('modify_by', { length: 255 }),\r\n\r\n    modifyAt: timestamp('modify_at')\r\n      .notNull()\r\n      .default(sql`now()`)\r\n      .$onUpdate(() => new Date()),\r\n  },\r\n  (table) => {\r\n    return {\r\n      idxPostEstateHistoryId: index('post_estate_history_id_idx').on(table.postEstateId, table.id),\r\n    };\r\n  },\r\n);\r\n", "import { ModalQuery, QueryResultPagination } from './../type/drizzle.type';\r\nimport { and, eq, inArray, sql, SQL } from 'drizzle-orm';\r\nimport { PgSelect } from 'drizzle-orm/pg-core';\r\nimport { NodeDatabase, ObjWriteInterface } from 'type/drizzle.type';\r\n\r\nexport class BaseRepository {\r\n  protected db: NodeDatabase;\r\n\r\n  constructor(db: NodeDatabase) {\r\n    this.db = db;\r\n  }\r\n\r\n  /**\r\n   * TODO: Check data if array convert to object, if data undefined return null\r\n   * @param data\r\n   * @returns object | null\r\n   */\r\n  public transformArrayToObject<T>(data: unknown) {\r\n    const hasArray = Array.isArray(data);\r\n    if (hasArray) {\r\n      return data?.[0] ?? null;\r\n    }\r\n\r\n    if (!data) return null;\r\n\r\n    return data as T;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo insert value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param obj value insert schema\r\n   * @returns object | null\r\n   */\r\n  public async insert<T>(model: ModalQuery, obj: ObjWriteInterface): Promise<T> {\r\n    const $query = await this.db\r\n      .insert(model)\r\n      .values({ ...obj })\r\n      .returning();\r\n\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo insert many value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param arrayObj value array insert schema\r\n   * @returns boolean\r\n   */\r\n  public async insertMany(model: ModalQuery, arrayObj: ObjWriteInterface[]): Promise<boolean> {\r\n    await this.db\r\n      .insert(model)\r\n      .values([...arrayObj])\r\n      .returning();\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo update value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param obj value update schema\r\n   * @returns return object | null\r\n   */\r\n  public async update<T>(modal: ModalQuery, obj: ObjWriteInterface): Promise<T> {\r\n    const $query = await this.db\r\n      .update(modal)\r\n      .set({ ...obj })\r\n      .returning();\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo update many value generic type response\r\n   * @param model type model schema and table insert\r\n   * @param arrayObj value array update schema\r\n   * @returns boolean\r\n   */\r\n  public async updateMany(model: ModalQuery, arrayObj: ObjWriteInterface[]): Promise<boolean> {\r\n    for (let obj of arrayObj) {\r\n      await this.update(model, obj);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo delete value with key id\r\n   * @param model type model schema and table delete\r\n   * @param id value id item delete string or array string\r\n   * @returns boolean\r\n   */\r\n  public async deleteById(model: ModalQuery, id: string | string[]): Promise<boolean> {\r\n    const hasArray = Array.isArray(id);\r\n    const $sql = hasArray ? inArray(model.id, id) : eq(model.id, id);\r\n\r\n    await this.db.delete(model).where($sql);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TODO: Base repo delete value with object key and value\r\n   * @param model type model schema and table delete\r\n   * @param objKeyValue object key and value from query\r\n   * @returns boolean\r\n   */\r\n  public async deleteByKey(model: ModalQuery, objKeyValue: Record<string, string | number>): Promise<boolean> {\r\n    // Mapper sql to objKeyValue\r\n    let $sqlChunk: SQL[] = [];\r\n    for (const key in objKeyValue) {\r\n      const hasValue = objKeyValue[key] !== undefined && objKeyValue[key] !== null;\r\n      if (!hasValue) continue;\r\n\r\n      $sqlChunk.push(eq(model[key], objKeyValue[key]));\r\n    }\r\n\r\n    await this.db.delete(model).where(and(sql.join($sqlChunk)));\r\n    return true;\r\n  }\r\n\r\n\r\n   /**\r\n   * TODO: Base repo find fist by key\r\n   * @param model type model schema and table delete\r\n   * @param objKeyValue object key and value from query\r\n   * @returns object | null\r\n   */\r\n  public async findByKey(model: ModalQuery, objKeyValue: Record<string, string | number>) {\r\n    let $sqlChunk: SQL[] = [];\r\n    for (const key in objKeyValue) {\r\n      const hasValue = objKeyValue[key] !== undefined && objKeyValue[key] !== null;\r\n      if (!hasValue) continue;\r\n\r\n      $sqlChunk.push(eq(model[key], objKeyValue[key]));\r\n    }\r\n\r\n    const $query = await this.db\r\n      .select()\r\n      .from(model)\r\n      .where(and(sql.join($sqlChunk)))\r\n      .limit(1);\r\n    return this.transformArrayToObject($query);\r\n  }\r\n\r\n  public async pagination<T extends PgSelect>(query: T, page: number, limit: number): Promise<QueryResultPagination> {\r\n    const subQuery = query.as('sub');\r\n    const totalRecordsQuery = this.db.select({ total: sql<number>`count(*)` }).from(subQuery);\r\n\r\n    const totalRecordsResult = await totalRecordsQuery.execute();\r\n    const totalRecords = Number(totalRecordsResult[0].total);\r\n    const totalPages = Math.ceil(totalRecords / limit);\r\n\r\n    const $offset = (page - 1) * limit;\r\n    query.limit(limit).offset($offset);\r\n\r\n    const results = (await query.execute()) as T[];\r\n\r\n    return {\r\n      data: results,\r\n      pagination: {\r\n        totalRecords: totalRecords,\r\n        totalPages: totalPages,\r\n        currentPage: page,\r\n        limit: limit,\r\n      },\r\n    };\r\n  }\r\n}\r\n", "export const APP_MESSAGE = Object.freeze({\r\n  BAD_REQUEST: \"Bad request\",\r\n  SUCCESS: \"Success\",\r\n  SERVER_INTERNAL: \"Server internal\",\r\n  NOT_FOUND: \"Server not found\",\r\n  ACCESS_DENIED: \"Access denied\",\r\n});\r\n", "import { APP_MESSAGE } from './message.helper';\r\n\r\nexport class ValidateError extends Error {\r\n  constructor(issue: any) {\r\n    super(APP_MESSAGE.BAD_REQUEST);\r\n    this.stack = issue\r\n\r\n    Object.setPrototypeOf(this, ValidateError.prototype);\r\n  }\r\n}\r\n\r\nexport class AppNotFound extends Error {\r\n  constructor() {\r\n    super(APP_MESSAGE.NOT_FOUND);\r\n\r\n    Object.setPrototypeOf(this, AppNotFound.prototype);\r\n  }\r\n}\r\n\r\nexport class AppServerInternal extends Error {\r\n  constructor(message?: string | any) {\r\n    super(message ?? APP_MESSAGE.SERVER_INTERNAL);\r\n\r\n    Object.setPrototypeOf(this, AppServerInternal.prototype);\r\n  }\r\n}\r\n\r\nexport class AppBadRequest extends Error {\r\n  constructor(message?: string) {\r\n    super(message ?? APP_MESSAGE.BAD_REQUEST);\r\n\r\n    Object.setPrototypeOf(this, AppBadRequest.prototype);\r\n  }\r\n}\r\n\r\nexport class AppAccessDenied extends Error {\r\n  constructor() {\r\n    super(APP_MESSAGE.ACCESS_DENIED);\r\n\r\n    Object.setPrototypeOf(this, AppAccessDenied.prototype);\r\n  }\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { ConvertString } from 'helper/convert-string';\r\nimport { commonLandModel } from 'models';\r\nimport { CommonLandModelWrite, CreateCommonLandInterface } from 'type/common-land.type';\r\nimport { BaseRepository } from 'helper/base-repositories';\r\nimport { IValidateHttp } from 'type/common.type';\r\nimport { ValidateError } from 'helper/app-exception.helper';\r\n\r\nexport class CommonLandService extends BaseRepository {\r\n  constructor(protected readonly app: FastifyInstance) {\r\n    super(app.db);\r\n  }\r\n\r\n  public async create(obj: CreateCommonLandInterface) {\r\n    try {\r\n      const $slug = ConvertString.convertStringToSlug({ text: obj.name });\r\n\r\n      const validateError = await this.validate(obj.name, obj.code);\r\n      const hasValidError = validateError.length > 0;\r\n      if (hasValidError) {\r\n        throw new ValidateError(validateError);\r\n      }\r\n\r\n      const $commonLandInsert: CommonLandModelWrite = {\r\n        code: obj.code,\r\n        name: obj.name,\r\n        provinceCode: obj.provinceCode,\r\n        districtCode: obj.districtCode,\r\n        wardCode: obj.wardCode,\r\n        slug: $slug,\r\n      };\r\n\r\n      const $result = await this.insert(commonLandModel, $commonLandInsert);\r\n\r\n      return $result;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async delete(id: string) {}\r\n\r\n  protected async validate(name: string, code: string): Promise<IValidateHttp[]> {\r\n    const $validateError: IValidateHttp[] = [];\r\n\r\n    const [$queryWithName, $queryWithCode] = await Promise.allSettled([\r\n      await this.findByKey(commonLandModel, { name: name }),\r\n      await this.findByKey(commonLandModel, { code: code }),\r\n    ]);\r\n\r\n    if ($queryWithName !== null) {\r\n      $validateError.push({\r\n        code: 'INVALID',\r\n        field: 'name',\r\n        message: 'Invalid name',\r\n      });\r\n    }\r\n\r\n    if ($queryWithCode !== null) {\r\n      $validateError.push({\r\n        code: 'INVALID',\r\n        field: 'code',\r\n        message: 'Invalid code',\r\n      });\r\n    }\r\n\r\n   \r\n    return $validateError\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["common_land_handler_exports", "__export", "CommonLandHandler", "__toCommonJS", "ConvertString", "option", "text", "slugConvert", "slug", "url", "entityKind", "hasOwnEntityKind", "is", "value", "type", "cls", "_a", "Column", "table", "config", "value", "entityKind", "__publicField", "_a", "ColumnBuilder", "name", "dataType", "columnType", "value", "fn", "entityKind", "__publicField", "TableName", "Schema", "Columns", "ExtraConfigColumns", "OriginalName", "BaseName", "IsAlias", "ExtraConfigBuilder", "IsDrizzleTable", "_a", "Table", "entityKind", "name", "schema", "baseName", "__publicField", "getTableName", "table", "TableName", "InlineForeignKeys", "_a", "PgTable", "Table", "entityKind", "__publicField", "pgTableWithSchema", "name", "columns", "extraConfig", "schema", "baseName", "rawTable", "builtColumns", "colBuilderBase", "colBuilder", "column", "builtColumnsForExtraConfig", "table", "pgTable", "_a", "ForeignKeyBuilder", "config", "actions", "name", "columns", "foreignColumns", "action", "table", "ForeignKey", "entityKind", "__publicField", "builder", "columnNames", "column", "foreignColumnNames", "chunks", "PgTable", "iife", "fn", "args", "uniqueKeyName", "table", "columns", "PgTable", "_a", "UniqueConstraintBuilder", "name", "UniqueConstraint", "entityKind", "__publicField", "UniqueOnConstraintBuilder", "nullsNotDistinct", "column", "parsePgArrayValue", "arrayString", "startFrom", "inQuotes", "char", "parsePgNestedArray", "result", "lastCharIsComma", "value", "newStartFrom", "parsePgArray", "makePgArray", "array", "item", "_a", "PgColumnBuilder", "ColumnBuilder", "size", "PgArrayBuilder", "ref", "actions", "name", "config", "column", "table", "iife", "builder", "ForeignKeyBuilder", "foreignColumn", "ExtraConfigColumn", "entityKind", "__publicField", "PgColumn", "Column", "uniqueKeyName", "opClass", "IndexedColumn", "type", "indexConfig", "baseBuilder", "baseColumn", "PgArray", "_PgArray", "range", "value", "parsePgArray", "v", "isNestedArray", "a", "is", "makePgArray", "isPgEnumSym", "isPgEnum", "obj", "_a", "PgEnumColumnBuilder", "PgColumnBuilder", "name", "enumInstance", "table", "PgEnumColumn", "entityKind", "__publicField", "PgColumn", "config", "pgEnumWithSchema", "enumName", "values", "schema", "enumInstance", "name", "PgEnumColumnBuilder", "isPgEnumSym", "_a", "Subquery", "sql", "selection", "alias", "isWith", "entityKind", "__publicField", "WithSubquery", "version", "otel", "rawTracer", "tracer", "name", "fn", "version", "iife", "span", "e", "ViewBaseConfig", "_a", "FakePrimitiveParam", "entityKind", "__publicField", "isSQLWrapper", "value", "mergeQueries", "queries", "result", "query", "StringChunk", "SQL", "_SQL", "queryChunks", "noopDecoder", "config", "tracer", "span", "chunks", "_config", "escapeName", "escapeParam", "prepareTyping", "inlineParams", "paramStartIndex", "chunk", "is", "Name", "i", "p", "Table", "schemaName", "tableName", "Column", "View", "ViewBaseConfig", "viewName", "Param", "mappedValue", "typings", "Placeholder", "Subquery", "isPgEnum", "escapeString", "mappedValueAsString", "alias", "decoder", "condition", "isDriverValueEncoder", "value", "noopDecoder", "noopEncoder", "noopMapper", "_a", "Param", "encoder", "SQL", "entityKind", "__publicField", "sql", "strings", "params", "queryChunks", "StringChunk", "paramIndex", "param", "SQL", "empty", "fromList", "list", "raw", "str", "join", "chunks", "separator", "result", "i", "chunk", "identifier", "value", "Name", "placeholder", "name", "Placeholder", "encoder", "Param", "Aliased", "fieldAlias", "entityKind", "_a", "__publicField", "_a", "View", "entityKind", "ViewBaseConfig", "name", "schema", "selectedFields", "query", "SQL", "__publicField", "Column", "Table", "Subquery", "_a", "ColumnAliasProxyHandler", "table", "columnObj", "prop", "entityKind", "__publicField", "TableAliasProxyHandler", "alias", "replaceOriginalName", "target", "Table", "ViewBaseConfig", "columns", "proxiedColumns", "key", "value", "is", "Column", "RelationTableAliasProxyHandler", "aliasedTable", "tableAlias", "aliasedTableColumn", "column", "tableAlias", "ColumnAliasProxyHandler", "TableAliasProxyHandler", "mapColumnsInAliasedSQLToAlias", "query", "alias", "SQL", "mapColumnsInSQLToAlias", "sql", "c", "is", "Column", "_a", "PgDateColumnBaseBuilder", "PgColumnBuilder", "sql", "entityKind", "__publicField", "_a", "PgDateBuilder", "PgDateColumnBaseBuilder", "name", "table", "PgDate", "entityKind", "__publicField", "PgColumn", "value", "PgDateStringBuilder", "PgDateString", "_a", "PgIntegerBuilder", "PgColumnBuilder", "name", "table", "PgInteger", "entityKind", "__publicField", "PgColumn", "value", "integer", "_a", "PgJsonBuilder", "PgColumnBuilder", "name", "table", "PgJson", "entityKind", "__publicField", "PgColumn", "config", "value", "_a", "PgJsonbBuilder", "PgColumnBuilder", "name", "table", "PgJsonb", "entityKind", "__publicField", "PgColumn", "config", "value", "_a", "PgNumericBuilder", "PgColumnBuilder", "name", "precision", "scale", "table", "PgNumeric", "entityKind", "__publicField", "PgColumn", "config", "numeric", "_a", "PgRealBuilder", "PgColumnBuilder", "name", "length", "table", "PgReal", "entityKind", "__publicField", "PgColumn", "config", "value", "real", "_a", "PgTextBuilder", "PgColumnBuilder", "name", "config", "table", "PgText", "entityKind", "__publicField", "PgColumn", "text", "_a", "PgTimeBuilder", "PgDateColumnBaseBuilder", "name", "withTimezone", "precision", "table", "PgTime", "entityKind", "__publicField", "PgColumn", "config", "_a", "PgTimestampBuilder", "PgDateColumnBaseBuilder", "name", "withTimezone", "precision", "table", "PgTimestamp", "entityKind", "__publicField", "PgColumn", "config", "value", "PgTimestampStringBuilder", "PgTimestampString", "timestamp", "_a", "PgUUIDBuilder", "PgColumnBuilder", "name", "sql", "table", "PgUUID", "entityKind", "__publicField", "PgColumn", "uuid", "_a", "PgVarcharBuilder", "PgColumnBuilder", "name", "config", "table", "PgVarchar", "entityKind", "__publicField", "PgColumn", "varchar", "_a", "QueryPromise", "entityKind", "onRejected", "onFinally", "value", "reason", "onFulfilled", "__publicField", "orderSelectedFields", "fields", "pathPrefix", "result", "name", "field", "newPath", "is", "Column", "SQL", "Table", "haveSameKeys", "left", "right", "leftKeys", "rightKeys", "index", "key", "applyMixins", "baseClass", "extendedClasses", "extendedClass", "name", "getTableColumns", "table", "Table", "getTableLikeName", "is", "Subquery", "View", "ViewBaseConfig", "SQL", "_a", "DrizzleError", "message", "cause", "entityKind", "__publicField", "TransactionRollbackError", "bindIfParam", "value", "column", "isDriverValueEncoder", "isSQLWrapper", "is", "Param", "Placeholder", "Column", "Table", "View", "eq", "left", "right", "sql", "ne", "and", "unfilteredConditions", "conditions", "c", "SQL", "StringChunk", "or", "not", "condition", "gt", "gte", "lt", "lte", "inArray", "values", "v", "notInArray", "isNull", "isNotNull", "exists", "subquery", "notExists", "between", "min", "max", "notBetween", "like", "notLike", "ilike", "notIlike", "asc", "column", "sql", "desc", "_a", "Relation", "sourceTable", "referencedTable", "relationName", "Table", "entityKind", "__publicField", "Relations", "table", "config", "_One", "isNullable", "fieldName", "relation", "One", "_Many", "Many", "getOperators", "and", "between", "eq", "exists", "gt", "gte", "ilike", "inArray", "isNull", "isNotNull", "like", "lt", "lte", "ne", "not", "notBetween", "notExists", "notLike", "notIlike", "notInArray", "or", "sql", "getOrderByOperators", "asc", "desc", "normalizeRelation", "schema", "tableNamesMap", "relation", "is", "One", "referencedTableTsName", "Table", "referencedTableConfig", "sourceTable", "sourceTableTsName", "reverseRelations", "referencedTableRelation", "_a", "PgViewBase", "View", "entityKind", "__publicField", "_a", "PgDialect", "migrations", "session", "config", "migrationsTable", "migrationsSchema", "migrationTableCreate", "sql", "lastDbMigration", "tx", "migration", "stmt", "name", "num", "str", "queries", "withSqlChunks", "w", "table", "where", "returning", "withList", "withSql", "returningSql", "whereSql", "set", "tableColumns", "Table", "columnNames", "colName", "setSize", "i", "col", "value", "res", "setSql", "fields", "isSingleTable", "columnsLen", "chunks", "field", "chunk", "is", "SQL", "query", "c", "PgColumn", "Column", "fieldsFlat", "having", "joins", "orderBy", "groupBy", "limit", "offset", "lockingClause", "distinct", "setOperators", "fieldsList", "orderSelectedFields", "f", "getTableName", "Subquery", "PgViewBase", "ViewBaseConfig", "alias", "tableName", "distinctSql", "selection", "tableSql", "fullName", "joinsArray", "index", "joinMeta", "lateralSql", "PgTable", "tableSchema", "origTableName", "View", "viewName", "viewSchema", "origViewName", "joinsSql", "havingSql", "orderBySql", "groupBySql", "limitSql", "offsetSql", "lockingClauseSql", "clauseSql", "finalQuery", "leftSelect", "setOperator", "rest", "type", "isAll", "rightSelect", "leftChunk", "rightChunk", "orderByValues", "singleOrderBy", "operatorChunk", "values", "onConflict", "valuesSqlList", "columns", "colEntries", "insertOrder", "column", "valueIndex", "valueList", "fieldName", "colValue", "Param", "defaultFnResult", "defaultValue", "onUpdateFnResult", "newValue", "valuesSql", "onConflictSql", "view", "concurrently", "withNoData", "concurrentlySql", "withNoDataSql", "encoder", "PgJsonb", "PgJson", "PgNumeric", "PgTime", "PgTimestamp", "PgTimestampString", "PgDate", "PgDateString", "PgUUID", "invokeSource", "fullSchema", "schema", "tableNamesMap", "tableConfig", "tableAlias", "nestedQueryRelation", "joinOn", "key", "aliasedTableColumn", "aliasedColumns", "getOperators", "mapColumnsInSQLToAlias", "fieldsSelection", "selectedColumns", "isIncludeMode", "selectedRelations", "entry", "tsKey", "queryConfig", "extras", "mapColumnsInAliasedSQLToAlias", "orderByOrig", "getOrderByOperators", "orderByValue", "selectedRelationTsKey", "selectedRelationConfigValue", "relation", "normalizedRelation", "normalizeRelation", "relationTableName", "relationTableTsName", "relationTableAlias", "and", "eq", "builtRelation", "One", "DrizzleError", "result", "isJson", "Many", "nestedSelection", "aliasedTable", "entityKind", "__publicField", "_a", "_SelectionProxyHandler", "config", "subquery", "prop", "ViewBaseConfig", "value", "is", "Subquery", "View", "SQL", "newValue", "Column", "ColumnAliasProxyHandler", "TableAliasProxyHandler", "SelectionProxyHandler", "entityKind", "__publicField", "_a", "TypedQueryBuilder", "entityKind", "__publicField", "_a", "PgSelectBuilder", "config", "source", "isPartialSelect", "fields", "is", "Subquery", "key", "PgViewBase", "ViewBaseConfig", "SQL", "getTableColumns", "PgSelectBase", "entityKind", "__publicField", "PgSelectQueryBuilderBase", "TypedQueryBuilder", "table", "session", "dialect", "withList", "distinct", "getTableLikeName", "joinType", "on", "baseTableName", "tableName", "join", "selection", "View", "Table", "SelectionProxyHandler", "type", "isAll", "rightSelection", "rightSelect", "getPgSetOperators", "haveSameKeys", "setOperators", "where", "having", "columns", "groupBy", "orderBy", "orderByArray", "limit", "offset", "strength", "_typings", "rest", "alias", "name", "joinsNotNullableMap", "tracer", "fieldsList", "orderSelectedFields", "query", "placeholderValues", "applyMixins", "QueryPromise", "createSetOperator", "leftSelect", "restSelects", "select", "setOperator", "union", "unionAll", "intersect", "intersectAll", "except", "exceptAll", "_a", "QueryBuilder", "alias", "queryBuilder", "qb", "WithSubquery", "SelectionProxyHandler", "queries", "self", "select", "fields", "PgSelectBuilder", "selectDistinct", "selectDistinctOn", "on", "PgDialect", "entityKind", "__publicField", "_a", "IndexBuilderOn", "unique", "name", "columns", "IndexBuilder", "it", "is", "SQL", "clonedIndexedColumn", "IndexedColumn", "method", "entityKind", "__publicField", "only", "obj", "condition", "table", "Index", "config", "index", "PgViewConfig", "_a", "DefaultViewBuilderCore", "name", "schema", "config", "entityKind", "__publicField", "ViewBuilder", "qb", "QueryBuilder", "selectionProxy", "SelectionProxyHandler", "aliasedSelection", "PgView", "ManualViewBuilder", "columns", "getTableColumns", "pgTable", "query", "MaterializedViewBuilderCore", "using", "tablespace", "MaterializedViewBuilder", "PgMaterializedView", "ManualMaterializedViewBuilder", "PgViewBase", "PgViewConfig", "pgConfig", "PgMaterializedViewConfig", "pgViewWithSchema", "selection", "pgMaterializedViewWithSchema", "_a", "PgSchema", "schemaName", "name", "columns", "extraConfig", "pgTableWithSchema", "pgViewWithSchema", "pgMaterializedViewWithSchema", "values", "pgEnumWithSchema", "entityKind", "__publicField", "pgSchema", "name", "PgSchema", "postEstateModel", "pgSchema", "uuid", "sql", "varchar", "real", "integer", "text", "timestamp", "table", "index", "imageModel", "pgSchema", "uuid", "sql", "varchar", "integer", "postEstateModel", "timestamp", "table", "index", "commonLandModel", "pgSchema", "uuid", "sql", "varchar", "text", "integer", "timestamp", "table", "index", "postEstateDetailModel", "pgSchema", "uuid", "sql", "postEstateModel", "text", "real", "numeric", "integer", "varchar", "timestamp", "table", "postEstateReportModel", "pgSchema", "uuid", "sql", "varchar", "integer", "timestamp", "table", "index", "postEstateHistoryModel", "pgSchema", "uuid", "sql", "postEstateModel", "text", "varchar", "timestamp", "table", "index", "BaseRepository", "db", "data", "model", "obj", "$query", "arrayObj", "modal", "id", "$sql", "inArray", "eq", "objKeyValue", "$sqlChunk", "key", "and", "sql", "query", "page", "limit", "subQuery", "totalRecordsResult", "totalRecords", "totalPages", "$offset", "APP_MESSAGE", "ValidateError", "issue", "APP_MESSAGE", "CommonLandService", "BaseRepository", "app", "obj", "$slug", "ConvertString", "validateError", "ValidateError", "$commonLandInsert", "commonLandModel", "error", "id", "name", "code", "$validateError", "$queryWithName", "$queryWithCode", "_commonLandService", "CommonLandHandler", "app", "__privateAdd", "request", "reply", "body", "useCase", "__privateGet", "__privateSet", "CommonLandService"]
}
